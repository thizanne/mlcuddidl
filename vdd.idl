/* -*- mode: c -*- */

/* This file is part of the MLCUDDIDL Library, released under LGPL license.
   Please read the COPYING file packaged in the distribution  */

quote(C, "
#include \"caml/custom.h\"
#include \"cudd_caml.h\"
")

import "man.idl";
import "bdd.idl";

/* ********************************************************************** */
/* Management of abstract datatypes */
/* ********************************************************************** */

/* For nodes that need Garbage collection */
typedef [abstract,c2ml(camlidl_cudd_node_c2ml),ml2c(camlidl_cudd_node_ml2c)] struct node__t vdd__t;
typedef [abstract,c2ml(camlidl_cudd_leaf_c2ml),ml2c(camlidl_cudd_leaf_ml2c)] struct vdd__leaf vdd__leaf;

quote(MLMLI,"
(** Public type for exploring the abstract type [t] *)
type +'a vdd = 
| Leaf of 'a         (** Terminal value *)
| Ite of int * 'a t * 'a t (** Decision on CUDD variable *)\n	\

")

quote(MLI,"
(** We refer to the module {!Add} for the description of the interface, as
it is nearly identical to {!Add}, except that real leaves are replaced by
OCaml leaves. 

IMPORTANT NOTE: this is an internal module, which assumes that leaves are
either immediate values (booleans, integers, constant sums), 
or values allocated with caml_alloc_shr (that can 
be moved only during a memory compaction).

The only case where you may use directly {!Vdd} without worrying is when the
leaves are represented as immediate values (booleans, integers, constant
sums) in the heap.

Otherwise, use module {!Mtbdd} or {!Mtbddc} to be safe, and also to ensure
that you do not have two constant MTBDDs pointing to different but
semantically equivalent values.
 *)
")

/* ====================================================================== */
/* Internal use */
/* ====================================================================== */
quote(ML,"")
quote(ML,"(*  ====================================================== *)")
quote(ML,"(** {2 For internal use} *)")
quote(ML,"(*  ====================================================== *)")

quote(ML,"
type _internal_ddtype = int (* 0:ADD, 1:IDD, 2:VDD *)
let _internal_ddtype = 2
external _internal_dval : _internal_ddtype -> 'a t -> 'a = \"camlidl_cudd_avdd_dval\"
external _internal_inspect: _internal_ddtype -> 'a t -> 'a vdd = \"camlidl_cudd_avdd_inspect\"
external _internal_cst : _internal_ddtype -> Man.v Man.t -> 'a -> 'a t = \"camlidl_cudd_avdd_cst\"
external _internal_is_eval_cst : _internal_ddtype -> 'a t -> Man.v Bdd.t -> 'a option = \"camlidl_cudd_avdd_is_eval_cst\"
external _internal_is_ite_cst : _internal_ddtype -> Man.v Bdd.t -> 'a t -> 'a t -> 'a option = \"camlidl_cudd_avdd_is_ite_cst\"

external _internal_iter_cube: _internal_ddtype -> (Man.tbool array -> 'a -> unit) -> 'a t -> unit = \"camlidl_cudd_avdd_iter_cube\"
external _internal_nodes_below_level: _internal_ddtype -> 'a t -> int option -> int option -> 'a t array = \"camlidl_cudd_avdd_nodes_below_level\"
external _internal_guard_of_leaf : _internal_ddtype -> 'a t -> 'a -> Man.v Bdd.t = \"camlidl_cudd_avdd_guard_of_leaf\"
external _internal_leaves: _internal_ddtype -> 'a t -> 'a array = \"camlidl_cudd_avdd_leaves\"
external _internal_pick_leaf : _internal_ddtype -> 'a t -> 'a = \"camlidl_cudd_avdd_pick_leaf\"
")

/* ********************************************************************** */
/* Extractors */
/* ********************************************************************** */
quote(MLMLI,"")
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Extractors} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external manager : 'a t -> Man.v Man.t = \"camlidl_bdd_manager\"
external is_cst : 'a t -> bool = \"camlidl_bdd_is_cst\"
external topvar : 'a t -> int = \"camlidl_bdd_topvar\"
external dthen : 'a t -> 'a t = \"camlidl_add_dthen\"
external delse : 'a t -> 'a t = \"camlidl_add_delse\"
external cofactors : int -> 'a t -> 'a t * 'a t = \"camlidl_cudd_add_cofactors\"
external cofactor : 'a t -> Man.v Bdd.t -> 'a t = \"camlidl_add_cofactor\"
")
quote(MLI,"
val dval : 'a t -> 'a
val inspect : 'a t -> 'a vdd
")
quote(ML,"
let dval dd = _internal_dval _internal_ddtype dd
let inspect dd = _internal_inspect _internal_ddtype dd
")

/* ********************************************************************** */
/* Supports */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Supports} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external support : 'a t -> Man.v Bdd.t = \"camlidl_bdd_support\"
external supportsize : 'a t -> int = \"camlidl_bdd_supportsize\"
external is_var_in : int -> 'a t -> bool = \"camlidl_bdd_is_var_in\"
external vectorsupport : 'a t array -> Man.v Bdd.t = \"camlidl_bdd_vectorsupport\"
external vectorsupport2 : Man.v Bdd.t array -> 'a t array -> Man.v Bdd.t = \"camlidl_add_vectorsupport2\"
")

/* ********************************************************************** */
/* Classical operations */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Classical operations} *)")
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"
val cst : Man.v Man.t -> 'a -> 'a t

(** Be cautious, it is basically of type {Add.t}, so not type safe (if you use  {!nodes_below_level}, etc...: you can try to retrieve a constant value of some type and the C [double] of the background value will be treated as a C [value].*)val _background : Man.v Man.t -> 'a t
")
quote(ML,"
let cst man leaf = _internal_cst _internal_ddtype man leaf
let _background man : 'a t =  Obj.magic (Add.background (Obj.magic man))
  (** Be cautious, it is basically of type {Add.t}, so not type safe (if you use  {!nodes_below_level}, etc...: you can try to retrieve a constant value of some type and the C [double] of the background value will be treated as a C [value].*)")
quote(MLMLI,"
external ite : Man.v Bdd.t -> 'a t -> 'a t -> 'a t = \"camlidl_add_ite\"
external ite_cst : Man.v Bdd.t -> 'a t -> 'a t -> 'a t option = \"camlidl_cudd_add_ite_cst\"
external eval_cst : 'a t -> Man.v Bdd.t -> 'a t option = \"camlidl_cudd_add_eval_cst\"
external compose : int -> Man.v Bdd.t -> 'a t -> 'a t = \"camlidl_add_compose\"
external vectorcompose: Man.v Bdd.t array -> 'a t -> 'a t = \"camlidl_add_vectorcompose\"
")

/* ********************************************************************** */
/* Logical tests */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Logical tests} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external is_equal : 'a t -> 'a t -> bool = \"camlidl_bdd_is_equal\"
external is_equal_when : 'a t -> 'a t -> Man.v Bdd.t -> bool = \"camlidl_bdd_is_equal_when\"
")
quote(MLI,"
val is_eval_cst : 'a t -> Man.v Bdd.t -> 'a option
val is_ite_cst : Man.v Bdd.t -> 'a t -> 'a t -> 'a option
")
quote(ML,"
let is_eval_cst dd bdd = _internal_is_eval_cst _internal_ddtype dd bdd
let is_ite_cst bdd dd1 dd2 = _internal_is_ite_cst _internal_ddtype bdd dd1 dd2
")

/* ********************************************************************** */
/* Structural information */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Structural information} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external size : 'a t -> int = \"camlidl_bdd_size\"
external nbpaths : 'a t -> float = \"camlidl_bdd_nbpaths\"
external nbnonzeropaths : 'a t -> float = \"camlidl_bdd_nbtruepaths\"
external nbminterms : int -> 'a t -> float = \"camlidl_bdd_nbminterms\"
external density : int -> 'a t -> float = \"camlidl_bdd_density\"
external nbleaves : 'a t -> int = \"camlidl_add_nbleaves\"
")

/* ********************************************************************** */
/* Variable Mapping */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Variable mapping} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external varmap : 'a t -> 'a t = \"camlidl_add_varmap\"
external permute : 'a t -> int array -> 'a t = \"camlidl_add_permute\"
")

/* ********************************************************************** */
/* Iterators */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Iterators} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLI,"
val iter_cube : (Man.tbool array -> 'a -> unit) -> 'a t -> unit
")
quote(ML,"let iter_cube f dd = _internal_iter_cube _internal_ddtype f dd")
quote(MLMLI, "
external iter_node: ('a t -> unit) -> 'a t -> unit = \"camlidl_cudd_iter_node\"
")

/* ********************************************************************** */
/* Leaves and guards */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Leaves and guards} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external guard_of_node : 'a t -> 'a t -> Man.v Bdd.t = \"camlidl_add_guard_of_node\"
external guard_of_nonbackground : 'a t -> Man.v Bdd.t = \"camlidl_add_guard_of_nonbackground\"
")

quote(MLI,"
(** [Cuddaux_NodesBelowLevel]. [nodes_below_level ?max f olevel] returns all (if [max=None]), otherwise at most [Some max] nodes pointed by the ADD, indexed by a variable of level greater or equal than [level], and encountered first in the top-down exploration (i.e., whenever a node is collected, its sons are not collected). If [olevel=None], then only constant nodes are collected. *)
val nodes_below_level: ?max:int -> 'a t -> int option -> 'a t array

(** Guard of the given leaf *)
val guard_of_leaf : 'a t -> 'a -> Man.v Bdd.t

(** Returns the set of leaf values (excluding the background value) *)
val leaves: 'a t -> 'a array

(** Picks (but not randomly) a non background leaf. Return [None] if the only leaf is the background leaf. *)
val pick_leaf : 'a t -> 'a

(** Returns the set of leaf values together with their guard in the ADD *)
val guardleafs : 'a t -> (Man.v Bdd.t * 'a) array
")
quote(ML,"
let nodes_below_level ?max vdd olevel =
  _internal_nodes_below_level _internal_ddtype vdd olevel max
let guard_of_leaf dd leaf = _internal_guard_of_leaf _internal_ddtype dd leaf
let leaves dd = _internal_leaves _internal_ddtype dd
let pick_leaf dd = _internal_pick_leaf _internal_ddtype dd
let guardleafs (vdd:'a t) : (Man.v Bdd.t * 'a) array =
  let tab = leaves vdd in
  Array.map (fun leaf -> (guard_of_leaf vdd leaf,leaf)) tab
")

/* ********************************************************************** */
/* Minimizations */
/* ********************************************************************** */
quote(MLMLI,"")
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Minimizations} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external constrain: 'a t -> Man.v Bdd.t -> 'a t = \"camlidl_add_constrain\"
external tdconstrain: 'a t -> Man.v Bdd.t -> 'a t = \"camlidl_add_tdconstrain\"
external restrict: 'a t -> Man.v Bdd.t -> 'a t = \"camlidl_add_restrict\"
external tdrestrict : 'a t -> Man.v Bdd.t -> 'a t = \"camlidl_add_tdrestrict\"
")

/* ********************************************************************** */
/* Conversions */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Conversions} *)")
quote(MLMLI,"(* ====================================================== *)")

/* ********************************************************************** */
/* User operations */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 User operations} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
(**
Two options:
- By decomposition into guards and leafs: see module {!Mapleaf}
- By using CUDD cache: see module {!User}
*)
")

/* ********************************************************************** */
/* Miscellaneous */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Miscellaneous} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external transfer : 'a t -> Man.v Man.t -> 'a t = \"camlidl_add_transfer\"
")

/* ********************************************************************** */
/* Printing */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Printing} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLI,"
val print__minterm:
  (Format.formatter -> 'a -> unit) ->
  Format.formatter -> 'a t -> unit
val print_minterm:
  (Format.formatter -> int -> unit) ->
  (Format.formatter -> 'a -> unit) ->
  Format.formatter -> 'a t -> unit
val print:
  (Format.formatter -> Man.v Bdd.t -> unit) ->
  (Format.formatter -> 'a -> unit) ->
  Format.formatter -> 'a t -> unit
")


quote(ML,"
open Format

let print__minterm print_leaf fmt dd =
  if is_cst dd then print_leaf fmt (dval dd)
  else
    let nb = nbpaths dd in
    if nb > (float_of_int !Man.print_limit) then
      fprintf fmt \"dd with %i nodes, %i leaves and %g paths\" (size dd) (nbleaves dd) nb
  else begin
    fprintf fmt \"@[<v>\";
    let first = ref true in
    iter_cube
      (begin fun cube leaf ->
	if not !first then fprintf fmt \"@ \" else first := false;
	let str = String.create (Array.length cube) in
	Array.iteri
	  (begin fun i elt ->
	    str.[i] <-
	      begin match elt with
	      | Man.False -> '0'
	      | Man.True -> '1'
	      | Man.Top -> '-'
	      end
	  end)
	  cube;
	fprintf fmt \"%s -> %a\" str print_leaf leaf
      end)
      dd;
    fprintf fmt \"@]\"
  end

let print print_bdd print_leaf fmt dd =
  if is_cst dd then print_leaf fmt (dval dd)
  else
    let nb = nbpaths dd in
    if nb > (float_of_int !Man.print_limit) then
      fprintf fmt \"dd with %i nodes, %i leaves and %g paths\" (size dd) (nbleaves dd) nb
  else begin
    let leaves = leaves dd in
    fprintf fmt \"{ @[<v>\";
    for i=Array.length leaves - 1 downto 0 do
      let leaf = leaves.(i) in
      let bdd = guard_of_leaf dd leaf in
      fprintf fmt \"%a IF %a\"
	print_leaf leaf print_bdd bdd;
      if i > 0 then
	fprintf fmt \",@ \";
    done;
    fprintf fmt \"@] }\"
  end

let print_minterm print_id print_leaf formatter dd =
  print (Bdd.print_minterm print_id) print_leaf formatter dd
")
