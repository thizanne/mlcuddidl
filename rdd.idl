/* -*- mode: c -*- */
/* $Id: rdd.idl,v 1.4 2004/10/01 18:05:23 bjeannet Exp $ */

/* This file is part of the MLCUDDIDL Library, released under LGPL license.
   Please read the COPYING file packaged in the distribution  */

quote(C, "
#include \"caml/custom.h\"
#include \"cudd_caml.h\"
")

import "man.idl";
import "bdd.idl";

/* ====================================================================== */
/* Management of abstract datatypes */
/* ====================================================================== */

/* For nodes that need Garbage collection */
typedef [abstract,c2ml(camlidl_cudd_node_c2ml),ml2c(camlidl_cudd_node_ml2c)] struct node__t rdd__t;

quote(MLMLI,"\
(** Public type for exploring the abstract type [t] *)
type rdd = 
| Leaf of float      (** Terminal value *)
| Ite of int * t * t (** Decision on CUDD variable *)

")

quote(MLI,"(** Dummy value (useful in some cases) *)")
quote(MLI,"val dummy : t")

/* ====================================================================== */
/* Internal use */
/* ====================================================================== */
quote(ML,"")
quote(ML,"(*  ====================================================== *)")
quote(ML,"(** {2 For internal use} *)")
quote(ML,"(*  ====================================================== *)")

quote(ML,"
type _internal_ddtype = int (* 0:RDD, 1:IDD, 2:VDD *)
let _internal_ddtype = 0
external _internal_dval : _internal_ddtype -> t -> float = \"camlidl_cudd_rivdd_dval\"
external _internal_inspect: _internal_ddtype -> t -> rdd = \"camlidl_cudd_rivdd_inspect\"
external _internal_cst : _internal_ddtype -> Man.dt -> float -> t = \"camlidl_cudd_rivdd_cst\"
external _internal_is_eval_cst : _internal_ddtype -> t -> Bdd.dt -> float option = \"camlidl_cudd_rivdd_is_eval_cst\"
external _internal_is_ite_cst : _internal_ddtype -> Bdd.dt -> t -> t -> float option = \"camlidl_cudd_rivdd_is_ite_cst\"

external _internal_iter_cube: _internal_ddtype -> (Man.tbool array -> float -> unit) -> t -> unit = \"camlidl_cudd_rivdd_iter_cube\"
external _internal_nodes_below_level: _internal_ddtype -> t -> int option -> int -> t array = \"camlidl_cudd_rivdd_nodes_below_level\"
external _internal_guard_of_leaf : _internal_ddtype -> t -> float -> Bdd.dt = \"camlidl_cudd_rivdd_guard_of_leaf\"
external _internal_leaves: _internal_ddtype -> t -> float array = \"camlidl_cudd_rivdd_leaves\"
external _internal_pick_leaf : _internal_ddtype -> t -> float = \"camlidl_cudd_rivdd_pick_leaf\"
")

/* ====================================================================== */
/* Extractors */
/* ====================================================================== */
quote(MLMLI,"")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Extractors} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLMLI,"
(** Returns the manager associated to the RDD *)
external manager : t -> Man.dt = \"camlidl_bdd_manager\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_IsConstant}[Cudd_IsConstant]}. Is the RDD constant ? *)
external is_cst : t -> bool = \"camlidl_bdd_is_cst\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_NodeReadIndex}[Cudd_NodeReadIndex]}. Returns the index of the RDD (65535 for a constant RDD) *)external topvar : t -> int = \"camlidl_bdd_topvar\"
")

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_T}[Cudd_T]}. Returns the positive subnode of the RDD *)")
rdd__t dthen(rdd__t no) quote(call, "
if (cuddIsConstant(no.node))
  failwith (\"Rdd.dthen: constant RDD\")
;
_res.man = no.man;
_res.node = cuddT(no.node);
");

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_E}[Cudd_E]}. Returns the negative subnode of the RDD *)")
rdd__t delse(rdd__t no) quote(call, "
if (cuddIsConstant(no.node))
  failwith (\"Rdd.delse: constant RDD\")
;
_res.man = no.man;
_res.node = cuddE(no.node);
");

quote(MLI,"
(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_V}[Cudd_V]}. Returns the value of the assumed constant RDD *)
val dval : t -> float
")
quote(ML,"let dval dd = _internal_dval _internal_ddtype dd")

quote(MLMLI,"
(** Returns the positive and negative cofactor of the RDD wrt the variable *)
external cofactors : int -> t -> t*t = \"camlidl_cudd_rdd_cofactors\"
")

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_Cofactor}[Cudd_Cofactor]}. [cofactor rdd cube] evaluates [rdd] on the cube [cube] *)")
rdd__t cofactor(rdd__t no1, bdd__dt no2) NO_OF_MAN_NO12(Cudd_Cofactor);

quote(MLI,"
(** Decomposes the top node of the RDD *)
val inspect : t -> rdd
")
quote(ML,"let inspect dd = _internal_inspect _internal_ddtype dd")

/* ====================================================================== */
/* Supports */
/* ====================================================================== */
quote(MLMLI,"")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Supports} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLMLI,"
(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_Support}[Cudd_Support]}. Returns the support (positive cube) of the RDD *)
external support : t -> Bdd.dt = \"camlidl_bdd_support\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_SupportSize}[Cudd_SupportSize]}. Returns the size of the support of the RDD *)
external supportsize : t -> int = \"camlidl_bdd_supportsize\"

(** [Cuddaux_IsVarIn]. Does the given variable belong to the support of the RDD ? *)
external is_var_in : int -> t -> bool = \"camlidl_bdd_is_var_in\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_VectorSupport}[Cudd_VectorSupport]}. Returns the support of the array of RDDs.

Raises a [Failure] exception in case where the array is of size 0 (in such
case, the manager is unknown, and we cannot return an empty support). *)
external vectorsupport : t array -> Bdd.dt = \"camlidl_bdd_vectorsupport\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_VectorSupport}[Cudd_VectorSupport]}. Returns the support of the BDDs and RDDs arrays.

Raises a [Failure] exception when both arrays are of size 0 (in such
case, the manager is unknown, and we cannot return an empty support). *)
external vectorsupport2 : Bdd.dt array -> t array -> Bdd.dt = \"camlidl_rdd_vectorsupport2\"
")

/* ====================================================================== */
/* Classical operations */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Classical operations} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"
(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addConst}[Cudd_addConst]}. Return a constant RDD with the given value. *)
val cst : Man.dt -> float -> t

val background : Man.dt -> t
")
quote(ML,"
let cst man leaf = _internal_cst _internal_ddtype man leaf
let background man = cst man (Man.get_background man)
")

quote(MLI,"(** [Cuddaux_addIte]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addIte}[Cudd_addIte]}. If-then-else operation, with the condition being a BDD. *)")
rdd__t ite(bdd__dt no1, rdd__t no2, rdd__t no3) NO_OF_MAN_NO123(Cuddaux_addIte);

quote(MLI,"(** [Cuddaux_addIteConstant]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addIteConstant}[Cudd_addIteConstant]}. If-then-else operation, which succeeds only if the resulting node belongs to one of the two RDD. *)")
[unique] rdd__t* ite_cst(bdd__dt no1, rdd__t no2, rdd__t no3)
quote(call,
"  {
     static rdd__t res;
     DdNode* node;
     CHECK_MAN3;
     node = Cuddaux_addIteConstant(no1.man->man,no1.node,no2.node,no3.node);
     if (node==DD_NON_CONSTANT)
       _res = NULL;
     else {
       res.man = no1.man;
       res.node = node;
       _res = &res;
     }
   }
");

quote(MLI,"(** [Cuddaux_addEvalConst]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addEvalConst}[Cudd_addEvalConst]}. *)")
[unique] rdd__t * eval_cst(rdd__t no1, bdd__dt no2)
quote(call,
"  {
     static rdd__t res;
     DdNode* node;

     CHECK_MAN2;
     node = Cuddaux_addEvalConst(no1.man->man,no2.node,no1.node);
     if (node==DD_NON_CONSTANT)
       _res = 0;
     else {
       res.man = no1.man;
       res.node = node;
       _res = &res;
     }
   }
");

quote(MLI,"(** [Cuddaux_addCompose]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addCompose}[Cudd_addCompose]}. Substitutes the variable with the BDD in the RDD. *)")
rdd__t compose(int var, bdd__dt no1, rdd__t no2)
     quote(call,"
CHECK_MAN2;
Begin_roots2(_v_no1,_v_no2);
_res.man = no1.man;
_res.node = Cuddaux_addCompose(no1.man->man, no2.node, no1.node, var);
End_roots();
");

quote(MLMLI,"
(** [Cuddaux_addVectorCompose]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addVectorCompose}[Cudd_addVectorCompose]}. Parallel substitution of every variable [var] present in the manager by the BDD [table.(var)] in the RDD. *)
external vectorcompose: Bdd.dt array -> t -> t = \"camlidl_rdd_vectorcompose\"
")

quote(ML,"let dummy = cst Man.dummy (Man.get_background Man.dummy)")

/* ====================================================================== */
/* Variable Mapping */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Variable mapping} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** [Cuddaux_addVarMap]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_bddVarMap}[Cudd_bddVarMap]}. Permutes the variables as it has been specified with {!Man.set_varmap}. *)")
rdd__t varmap(rdd__t no)
     quote(call, "
if (no.man->man->map == NULL){
  failwith(\"Rdd.varmap: empty table, Man.set_varmap has not been called !\");
}
Begin_roots1(_v_no);
_res.man = no.man;
_res.node = Cuddaux_addVarMap(no.man->man,no.node);
End_roots();
");

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addPermute}[Cudd_addPermute]}. Permutes the variables as it is specified by
[permut] (same format as in {!Man.set_varmap}). *)")
quote(MLMLI,"external permute : t -> int array -> t = \"camlidl_rdd_permute\"")

/* ====================================================================== */
/* Logical tests */
/* ====================================================================== */
quote(MLMLI,"")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Logical tests} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLMLI,"
(** Equality test *)
external is_equal: t -> t -> bool = \"camlidl_bdd_is_equal\"
(** Variation of {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_EquivDC}[Cudd_EquivDC]}. Are the two RDDs equal when the BDD (careset) is true ? *)
external is_equal_when: t -> t -> Bdd.dt -> bool = \"camlidl_bdd_is_equal_when\"
")

quote(MLI,"
(** Variation of [Cuddaux_addEvalConst]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addEvalConst}[Cudd_addEvalConst]}. Is the RDD constant when the BDD (careset) is true, and in this case what is its value ? *)
val is_eval_cst : t -> Bdd.dt -> float option

(** Is the result of [ite] constant, and if it is the case, what is its value ? *)
val is_ite_cst : Bdd.dt -> t -> t -> float option
")
quote(ML,"
let is_eval_cst dd bdd = _internal_is_eval_cst _internal_ddtype dd bdd
let is_ite_cst bdd dd1 dd2 = _internal_is_ite_cst _internal_ddtype bdd dd1 dd2
")

/* ====================================================================== */
/* Structural information */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Structural information} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLMLI,"
(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_DagSize}[Cudd_DagSize]}. Size if the RDD as a graph (the number of nodes). *)
external size :  t -> int = \"camlidl_bdd_size\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_CountPath}[Cudd_CountPath]}. Number of paths in the RDD from the root to the leafs. *)
external nbpaths : t -> float = \"camlidl_bdd_nbpaths\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_CountPathsToNonZero}[Cudd_CountPathsToNonZero]}. Number of paths in the RDD from the root to non-zero leaves. *)
external nbnonzeropaths : t -> float = \"camlidl_bdd_nbtruepaths\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_CountMinterm}[Cudd_CountMinterm]}. Number of minterms  of the RDD knowing that it depends on the given number of variables. *)
external nbminterms : int -> t -> float = \"camlidl_bdd_nbminterms\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_Density}[Cudd_Density]}. Density of the RDD, which is the ratio of the number of minterms to the number of nodes. The RDD is assumed to depend on [nvars] variables. *)
external density : int -> t -> float = \"camlidl_bdd_density\"
")

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_CountLeaves}[Cudd_CountLeaves]}. Number of leaves. *)")
int nbleaves(rdd__t no)
quote(call,
"_res = Cudd_CountLeaves(no.node); \
if (_res==CUDD_OUT_OF_MEM){ \
  failwith (\"Rdd.nbleaves returned CUDD_OUT_OF_MEM\"); \
}");

/* ====================================================================== */
/* Iterators */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Iterators} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLI,"
(** Similar to {!Bdd.iter_cube} *)
val iter_cube : (Man.tbool array -> float -> unit) -> t -> unit
")
quote(ML,"let iter_cube f dd = _internal_iter_cube _internal_ddtype f dd")

quote(MLMLI,"
(** Similar to {!Bdd.iter_node} *)
external iter_node: (t -> unit) -> t -> unit = \"camlidl_cudd_iter_node\"
")

/* ====================================================================== */
/* Leaves and guards */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Leaves and guards} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** [Cuddaux_addGuardOfNode]. [guard_of_node f node] returns the sum of the paths leading from the root node [f] to the node [node] of [f]. *)")
bdd__dt guard_of_node(rdd__t no1, rdd__t no2) NO_OF_MAN_NO12(Cuddaux_addGuardOfNode);
quote(MLI,"(** Guard of non background leaves *)")
bdd__dt guard_of_nonbackground(rdd__t no)
     quote(call,"
Begin_roots1(_v_no);
{
  DdNode* add = Cudd_ReadBackground(no.man->man);
  cuddRef(add);
  _res.man = no.man;
  _res.node = Cuddaux_addGuardOfNode(no.man->man,no.node,add);
  _res.node = Cudd_Not(_res.node);
  cuddDeref(add);
}
End_roots();
");


quote(MLI,"
(** [Cuddaux_NodesBelowLevel]. [nodes_below_level f olevel max] returns all (if [max<=0]), otherwise at most [max] nodes pointed by the RDD, indexed by a variable of level greater or equal than [level], and encountered first in the top-down exploration (i.e., whenever a node is collected, its sons are not collected). If [olevel=None], then only constant nodes are collected. The background node may be in the result. *)
val nodes_below_level: t -> int option -> int -> t array

(** Guard of the given leaf *)
val guard_of_leaf : t -> float -> Bdd.dt

(** Returns the set of leaf values (excluding the background value) *)
val leaves: t -> float array

(** Picks (but not randomly) a non background leaf. Return [None] if the only leaf is the background leaf. *)
val pick_leaf : t -> float

(** Returns the set of leaf values together with their guard in the RDD *)
val guardleafs : t -> (Bdd.dt * float) array
")
quote(ML,"
let nodes_below_level rdd olevel max = 
  _internal_nodes_below_level _internal_ddtype rdd olevel max
let guard_of_leaf dd leaf = _internal_guard_of_leaf _internal_ddtype dd leaf
let leaves dd = _internal_leaves _internal_ddtype dd
let pick_leaf dd = _internal_pick_leaf _internal_ddtype dd
let guardleafs rdd =
  let tab = leaves rdd in
  Array.map (fun leaf -> (guard_of_leaf rdd leaf,leaf)) tab
")

/* ====================================================================== */
/* Minimizations */
/* ====================================================================== */
quote(MLMLI,"")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Minimizations} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** See {!Bdd.constrain}, {!Bdd.tdconstrain}, {!Bdd.restrict}, {!Bdd.tdrestrict} *)\n")

rdd__t constrain(rdd__t no1, bdd__dt no2) NO_OF_MAN_NO12(Cuddaux_addConstrain);
rdd__t tdconstrain(rdd__t no1, bdd__dt no2) NO_OF_MAN_NO12(Cuddaux_addTDConstrain);
rdd__t restrict(rdd__t no1, bdd__dt no2) NO_OF_MAN_NO12(Cuddaux_addRestrict);
rdd__t tdrestrict(rdd__t no1, bdd__dt no2) NO_OF_MAN_NO12(Cuddaux_addTDRestrict);

/* ====================================================================== */
/* Conversions */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Conversions} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_BddToAdd}[Cudd_BddToAdd]}. Conversion from BDD to 0-1 RDD *)")
rdd__t of_bdd(bdd__dt no) NO_OF_MAN_NO(Cudd_BddToAdd);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addBddPattern}[Cudd_addBddPattern]}. Conversion from RDD to BDD by replacing all leaves different from 0  by true. *)")
bdd__dt to_bdd(rdd__t no) NO_OF_MAN_NO(Cudd_addBddPattern);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addBddThreshold}[Cudd_addBddThreshold]}. Conversion from RDD to BDD by replacing all leaves greater than or equal to the threshold by true. *)")
rdd__t to_bdd_threshold(double val, rdd__t no)
     quote(call,"
Begin_roots1(_v_no);
_res.man = no.man;
_res.node = Cudd_addBddThreshold(no.man->man,no.node,val);
End_roots();
");

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addBddStrictThreshold}[Cudd_addBddStrictThreshold]}. Conversion from RDD to BDD by replacing all leaves strictly greater than the threshold by true.*)")
rdd__t to_bdd_strictthreshold(double val, rdd__t no)
     quote(call,"
Begin_roots1(_v_no);
_res.man = no.man;
_res.node = Cudd_addBddStrictThreshold(no.man->man,no.node,val);
End_roots();
");

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addBddInterval}[Cudd_addBddInterval]}. Conversion from RDD to BDD  by replacing all leaves in the interval by true. *)")
rdd__t to_bdd_interval(double lower, double upper, rdd__t no)
     quote(call,"
Begin_roots1(_v_no);
_res.man = no.man;
_res.node = Cudd_addBddInterval(no.man->man,no.node,lower,upper);
End_roots();
");

/* ====================================================================== */
/* Quantifications */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Quantifications} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** Variation of {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addExistAbstract}[Cudd_addExistAbstract]}. Abstracts all the variables in the cube from the RDD by summing over all possible values taken by those variables. *)")
rdd__t exist(bdd__dt no1, rdd__t no2)
     quote(call,"
CHECK_MAN2();
Begin_roots2(_v_no1,_v_no2);
{
   DdNode* add1 = Cudd_BddToAdd(no1.man->man,no1.node);
  cuddRef(add1);
  _res.man = no1.man;
  _res.node = Cudd_addExistAbstract(no1.man->man,no2.node,add1);
  cuddRef(_res.node);
  Cudd_RecursiveDeref(no1.man->man,add1);
  cuddDeref(_res.node);
}
End_roots();
");

quote(MLI,"(** Variation of {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addUnivAbstract}[Cudd_addUnivAbstract]}. Abstracts all the variables in the cube from the RDD by taking the product over all possible values taken by those variables. *)")
rdd__t forall(bdd__dt no1, rdd__t no2)
     quote(call,"
CHECK_MAN2();
Begin_roots2(_v_no1,_v_no2);
{
  DdNode* add1 = Cudd_BddToAdd(no1.man->man,no1.node);
  cuddRef(add1);
  _res.man = no1.man;
  _res.node = Cudd_addUnivAbstract(no1.man->man,no2.node,add1);
  cuddRef(_res.node);
  Cudd_RecursiveDeref(no1.man->man,add1);
  cuddDeref(_res.node);
}
End_roots();
");

/*
rdd__t exist(bdd__t no1, rdd__t no2)
     NO_OF_MAN_NO21(Cudd_addExistAbstract);
rdd__t forall(bdd__t no1, rdd__t no2)
     NO_OF_MAN_NO21(Cudd_addUnivAbstract);
*/

/* ====================================================================== */
/* Algebraic operations */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Algebraic operations} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html# Cudd_addLeq}[ Cudd_addLeq]}. *)")
boolean is_leq(rdd__t no1, rdd__t no2)
  quote(call, "CHECK_MAN2; _res = Cudd_addLeq(no1.man->man,no1.node,no2.node);");

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addPlus}[Cudd_addPlus]}. *)")
rdd__t add(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addPlus);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addMinus}[Cudd_addMinus]}. *)")
rdd__t sub(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addMinus);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addTimes}[Cudd_addTimes]}. *)")
rdd__t mul(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addTimes);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addDivide}[Cudd_addDivide]}. *)")
rdd__t div(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addDivide);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addMinimum}[Cudd_addMinimum]}. *)")
rdd__t min(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addMinimum);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addMaximum}[Cudd_addMaximum]}. *)")
rdd__t max(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addMaximum);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addAgreement}[Cudd_addAgreement]}. *)")
rdd__t agreement(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addAgreement);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addDiff}[Cudd_addDiff]}. *)")
rdd__t diff(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addDiff);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addThreshold}[Cudd_addThreshold]}. *)")
rdd__t threshold(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addThreshold);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addSetNZ}[Cudd_addSetNZ]}. *)")
rdd__t setNZ(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addSetNZ);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addLog}[Cudd_addLog]}. *)")
rdd__t log(rdd__t no) APPLYUNOP(Cudd_addLog);

/* ====================================================================== */
/* Matrix Operations */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Matrix operations} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLMLI,"
(** Variation of {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addMatrixMultiply}[Cudd_addMatrixMultiply]}.

[matrix_multiply z A B] performs matrix multiplication of [A] and [B], with [z]
being the summation variables, which means that they are used to refer columns
of [A] and to rows of [B]. *)
external matrix_multiply : int array -> t -> t -> t = \"camlidl_rdd_matrix_multiply\"

(** Variation of {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addTimesPlus}[Cudd_addTimesPlus]}. *)
external times_plus : int array -> t -> t -> t = \"camlidl_rdd_times_plus\"

(** Variation of {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addTriangle}[Cudd_addTriangle]}. *)
external triangle : int array -> t -> t -> t = \"camlidl_rdd_triangle\"
")
quote(C,"
MATMUL(camlidl_rdd_matrix_multiply,Cudd_addMatrixMultiply)
MATMUL(camlidl_rdd_times_plus,Cudd_addTimesPlus)
MATMUL(camlidl_rdd_triangle,Cudd_addTriangle)
")

/* ====================================================================== */
/* User Operations */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 User operations} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {3 By decomposition into guards and leaves} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"(**
Be cautious: here the background leaf is used as a special value,
and should not be used for ordinary purpose.
*)")

quote(MLI,"
val mapleaf1 : (Bdd.dt -> float -> float) -> t -> t
val mapleaf2 : (Bdd.dt -> float -> float -> float) -> t -> t -> t
")
quote(ML,"
let mapleaf1
  (f:Bdd.dt -> float -> float)
  (rdd:t)
  :
  t
  =
  let manager = manager rdd in
  let background = Man.get_background manager in
  let leaves = leaves rdd in
  let res = ref (cst manager background) in
  for i=0 to pred (Array.length leaves) do
    let leaf = leaves.(i) in
    if leaf<>background then begin
      let guard = guard_of_leaf rdd leaves.(i) in
      let nleaf = f guard leaf in
      res := ite guard (cst manager nleaf) !res
    end
  done;
  !res

let mapleaf2
  (f:Bdd.dt -> float -> float -> float)
  (rdd1:t)
  (rdd2:t)
  :
  t
  =
  let manager = manager rdd1 in
  let background = Man.get_background manager in
  let ddbackground = cst manager background in
  let leaves1 = leaves rdd1 in
  let res = ref ddbackground in
  for i1=0 to pred (Array.length leaves1) do
    let leaf1 = leaves1.(i1) in
    if leaf1<>background then begin
      let guard1 = guard_of_leaf rdd1 leaf1 in
      let rdd2 = ite guard1 rdd2 ddbackground in
      let leaves2 = leaves rdd2 in
      for i2=0 to pred (Array.length leaves2) do
	let leaf2 = leaves2.(i2) in
	if leaf2<>background then begin
	  let guard2 = guard_of_leaf rdd2 leaf2 in
	  let nleaf = f guard2 leaf1 leaf2 in
	  res := ite guard2 (cst manager nleaf) !res
	end
      done
    end
  done;
  !res
")

quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {3 By using CUDD cache} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLI,"
(** {4 Type of operations} *)

type op1 
type op2 
type test2
type op3
type 'a exist

type auto = Custom.auto
type user = Custom.user
type 'a local = 'a Custom.local
type global = Custom.global
type 'a cache = 'a Custom.cache

type ('a,'b) op

val global : global cache
val auto : auto local cache
val user : user local cache
")
quote(ML,"
(** {4 Type of operations} *)

type op1 = (float, float) Custom.op1
type op2 = (float, float, float) Custom.op2
type test2 = (float, float) Custom.test2
type op3 = (float, float, float, float) Custom.op3
type 'a exist = (float,'a) Custom.exist

type auto = Custom.auto
type user = Custom.user
type 'a local = 'a Custom.local
type global = Custom.global
type 'a cache = 'a Custom.cache

type ('a,'b) op = ('a,'b) Custom.op

let global = Custom.global
let auto = Custom.auto
let user = Custom.user
")

quote(MLMLI,"
type 'a mexist = [
  | `Fun of (t -> t -> t option) option * (float -> float -> float)
  | `Op of (op2, 'a) op
]
")

quote(MLI,"
(** {4 Registering operations} *)

val register_op1 :
  cachetyp:'a cache -> (float -> float) -> (op1, 'a) op
val register_op2 :
  cachetyp:'a cache ->
  ?commutative:bool ->
  ?idempotent:bool ->
  ?special:(t -> t -> t option) ->
  (float -> float -> float) -> (op2, 'a) op
val register_test2 :
  cachetyp:'a cache ->
  ?commutative:bool ->
  ?reflexive:bool ->
  ?special:(t -> t -> bool option) ->
  (float -> float -> bool) -> (test2, 'a) op
val register_op3 :
  cachetyp:'a  local cache ->
  ?special:(t -> t -> t -> t option) ->
  (float -> float -> float -> float) -> 
  (op3, 'a local) op
val register_exist :
  cachetyp:'b cache -> (op2,'a) op -> ('a exist, 'b) op

(** {4 Flushing cache and removing user operations based on local caches} *)

val flush_op : ('a, user local) op -> unit
val flush_allop : unit -> unit

(** {4 Applying operations} *)

val apply_op1 : (op1, 'a) op -> t -> t
val apply_op2 : (op2, 'a) op -> t -> t -> t
val apply_test2 : (test2, 'a) op -> t -> t -> bool
val apply_op3 :
  (op3, 'a local) op ->
  t -> t -> t -> t
val apply_exist : ('a exist, 'b) op -> supp:(Bdd.dt) -> t -> t

(** {4 Map functions (based on automatic user caches)} *)

val map_op1 :
  (float -> float) -> t -> t
val map_op2 :
  ?commutative:bool ->
  ?idempotent:bool ->
  ?special:(t -> t -> t option) ->
  (float -> float -> float) -> 
  t -> t -> t
val map_test2 :
  ?commutative:bool ->
  ?reflexive:bool ->
  ?special:(t -> t -> bool option) ->
  (float -> float -> bool) -> 
  t -> t -> bool
val map_op3 :
  ?special:(t -> t -> t -> t option) ->
  (float -> float -> float -> float) -> 
  t -> t -> t -> t
val map_exist :
  'a mexist ->
  supp:(Bdd.dt) -> t -> t

")

quote(ML,"
let register_op1 ~cachetyp = Custom.register_op1 ~ddtyp:_internal_ddtype ~cachetyp
let register_op2 ~cachetyp = Custom.register_op2 ~ddtyp:_internal_ddtype ~cachetyp
let register_test2  ~cachetyp = Custom.register_test2 ~ddtyp:_internal_ddtype ~cachetyp
let register_op3 ~cachetyp = Custom.register_op3 ~ddtyp:_internal_ddtype ~cachetyp
let register_exist ~cachetyp (op:(op2,'a) Custom.op) = Custom.register_exist ~ddtyp:_internal_ddtype ~cachetyp op
let flush_op = Custom.flush_op
let flush_allop = Custom.flush_allop
let (apply_op1 : (op1,'a) Custom.op -> t -> t) = Custom.apply_op1 
let (apply_op2 : (op2,'a) Custom.op -> t -> t -> t) = Custom.apply_op2
let (apply_test2 : (test2,'a) Custom.op -> t -> t -> bool) = Custom.apply_test2 
let (apply_op3 : (op3,'a Custom.local) Custom.op -> t -> t -> t -> t) = Custom.apply_op3
let (apply_exist : ('a exist,'b) Custom.op -> supp:(Bdd.dt) -> t -> t) = Custom.apply_exist
let map_op1 = Custom.map_op1 ~ddtyp:_internal_ddtype
let map_op2 = Custom.map_op2 ~ddtyp:_internal_ddtype
let map_test2 = Custom.map_test2 ~ddtyp:_internal_ddtype
let map_op3 = Custom.map_op3 ~ddtyp:_internal_ddtype
let map_exist m = Custom.map_exist ~ddtyp:_internal_ddtype m
")

/* ====================================================================== */
/* Miscellaneous */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Miscellaneous} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** [Cuddaux_addTransfer]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_bddTransfer}[Cudd_bddTransfer]}. Transfers a RDD to a different manager. *)")
rdd__t transfer(rdd__t no, man__dt man)
     quote(call, "
Begin_roots2(_v_no,_v_man);
_res.man = man;
_res.node = Cuddaux_addTransfer(no.man->man,man->man,no.node);
End_roots();
");

/* ====================================================================== */
/* Printing */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Printing} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLMLI,"
(** C printing function. The output may mix badly with the OCaml output. *)
external _print: t -> unit = \"camlidl_cudd_print\"
")

quote(MLI,"
(** Prints the minterms of the BDD in the same way as {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_Printminterm}[Cudd_Printminterm]}. *)
val print__minterm: Format.formatter -> t -> unit

(** [print_minterm print_id print_leaf fmt bdd] prints the minterms of the BDD using [print_id] to print indices of variables and [print_leaf] to print leaf values. *)
val print_minterm: 
  (Format.formatter -> int -> unit) -> 
  (Format.formatter -> float -> unit) -> 
  Format.formatter -> t -> unit

(** Prints a BDD by recursively decomposing it as monomial followed by a tree. *)
val print: 
  (Format.formatter -> int -> unit) ->
  (Format.formatter -> float -> unit) -> 
  Format.formatter -> t -> unit  
")


quote(ML,"
open Format

let print__minterm fmt dd =
  if is_cst dd then pp_print_float fmt (dval dd)
  else
    let nb = nbpaths dd in
    if nb > (float_of_int !Man.print_limit) then
      fprintf fmt \"dd with %i nodes, %i leaves and %g paths\" (size dd) (nbleaves dd) nb
  else begin
    fprintf fmt \"@[<v>\";
    let first = ref true in
    iter_cube
      (begin fun cube leaf ->
	if not !first then fprintf fmt \"@ \" else first := false;
	let str = String.create (Array.length cube) in
	Array.iteri
	  (begin fun i elt ->
	    str.[i] <-
	      begin match elt with
	      | Man.False -> '0'
	      | Man.True -> '1'
	      | Man.Top -> '-'
	      end
	  end)
	  cube;
	fprintf fmt \"%s -> %g\" str leaf
      end)
      dd;
    fprintf fmt \"@]\"
  end

let print_minterm print_id print_leaf fmt dd =
  if is_cst dd then print_leaf fmt (dval dd)
  else
    let nb = nbpaths dd in
    if nb > (float_of_int !Man.print_limit) then
      fprintf fmt \"dd with %i nodes, %i leaves and %g paths\" (size dd) (nbleaves dd) nb
  else begin
    let leaves = leaves dd in
    fprintf fmt \"{ @[<v>\";
    for i=Array.length leaves - 1 downto 0 do
      let leaf = leaves.(i) in
      let bdd = guard_of_leaf dd leaf in
      fprintf fmt \"%a IF %a\"
	print_leaf leaf (Bdd.print_minterm print_id) bdd;
      if i > 0 then
	fprintf fmt \",@ \";
    done;
    fprintf fmt \"@] }\"
  end

let rec print print_id print_leaf formatter dd =
  match inspect dd with
  | Leaf(v) -> print_leaf formatter v
  | Ite(var,alors,sinon) ->
      fprintf formatter \"ITE(@[<hv>%a;@,%a;@,%a)@]\"
	print_id var (print print_id print_leaf) alors (print print_id print_leaf) sinon
")
