/* -*- mode: c -*- */
/* $Id: rdd.idl,v 1.4 2004/10/01 18:05:23 bjeannet Exp $ */

/* This file is part of the MLCUDDIDL Library, released under LGPL license.
   Please read the COPYING file packaged in the distribution  */

quote(C, "
#include \"caml/custom.h\"
#include \"cudd_caml.h\"
")

import "manager.idl";
import "bdd.idl";

/* ====================================================================== */
/* Management of abstract datatypes */
/* ====================================================================== */

/* For nodes that need Garbage collection */
typedef [abstract,c2ml(camlidl_cudd_node_c2ml),ml2c(camlidl_cudd_node_ml2c)] struct node__t rdd__t;
quote(MLI,"(** Binary Decision Diagrams with [float] leaves *)")

quote(MLMLI,"\
(** Public type for exploring the abstract type [t] *)\n\
type rdd = \n\
| Leaf of float \n\
| Ite of int * t * t \n\
\n\
\n\
type id_unop \n\
type id_binop \n\
type id_combinop \n\
  (** For user-defined operations *)\n\
")

quote(MLI,"(** Dummy value (useful in some cases) *)")
quote(MLI,"val dummy : t")

quote(MLI,"\n 
(** [t] is the abstract type for RDDs (which corresponds to CUDD ADDs). Objects
of this type contains both the top node of the RDD and the manager to which the
node belongs . The manager can be retrieved with {!manager}. Objects of this
type are automatically garbage collected. *)
")

/* ====================================================================== */
/* Extractors */
/* ====================================================================== */
quote(MLMLI,"")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Extractors} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLMLI,"
(** Returns the manager associated to the RDD *)
external manager : t -> Manager.t = \"camlidl_bdd_manager\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_IsConstant}[Cudd_IsConstant]}. Is the RDD constant ? *)
external is_cst : t -> bool = \"camlidl_bdd_is_cst\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_NodeReadIndex}[Cudd_NodeReadIndex]}. Returns the index of the RDD (65535 for a constant RDD) *)external topvar : t -> int = \"camlidl_bdd_topvar\"
")

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_T}[Cudd_T]}. Returns the positive subnode of the RDD *)")
rdd__t dthen(rdd__t no) quote(call, "
if (cuddIsConstant(no.node))
  failwith (\"Rdd.dthen: constant RDD\")
;
Begin_roots1(_v_no);
_res.man = no.man;
_res.node = cuddT(no.node);
End_roots();
");

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_E}[Cudd_E]}. Returns the negative subnode of the RDD *)")
rdd__t delse(rdd__t no) quote(call, "
if (cuddIsConstant(no.node))
  failwith (\"Rdd.delse: constant RDD\")
;
Begin_roots1(_v_no);
_res.man = no.man;
_res.node = cuddE(no.node);
End_roots();
");

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_V}[Cudd_V]}. Returns the value of the assumed constant RDD *)")
double dval(rdd__t no) quote(call,"
if (!cuddIsConstant(no.node))
  failwith(\"Rdd.dval: non constant RDD\")
;
_res = cuddV(no.node);
");

quote(MLI,"(** Returns the positive and negative cofactor of the RDD wrt the variable *)")
void cofactors(int var, rdd__t no, [out] rdd__t noa, [out] rdd__t nob)
  quote(call," {
  DdNode* cof;
  noa.man = nob.man = no.man;
  Begin_roots1(_v_no);
  cof = Cudd_bddIthVar(no.man, var);
  noa.node = Cudd_Cofactor(no.man,no.node,cof);
  nob.node = Cudd_Cofactor(no.man,no.node,Cudd_Not(cof));
  End_roots();
  }
");

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_Cofactor}[Cudd_Cofactor]}. [cofactor rdd cube] evaluates [rdd] on the cube [cube] *)")
rdd__t cofactor(rdd__t no1, bdd__t no2) NO_OF_MAN_NO12(Cudd_Cofactor);

quote(MLI,"(** Decomposes the top node of the RDD *)")
quote(MLMLI,"external inspect: rdd__t -> rdd = \"camlidl_rdd_inspect\"")

/* ====================================================================== */
/* Supports */
/* ====================================================================== */
quote(MLMLI,"")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Supports} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLMLI,"
(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_Support}[Cudd_Support]}. Returns the support (positive cube) of the RDD *)
external support : t -> Bdd.t = \"camlidl_bdd_support\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_SupportSize}[Cudd_SupportSize]}. Returns the size of the support of the RDD *)
external supportsize : t -> int = \"camlidl_bdd_supportsize\"

(** [Cuddaux_IsVarIn]. Does the given variable belong to the support of the RDD ? *)
external is_var_in : int -> t -> bool = \"camlidl_bdd_is_var_in\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_VectorSupport}[Cudd_VectorSupport]}. Returns the support of the array of RDDs. 

Raises a [Failure] exception in case where the array is of size 0 (in such
case, the manager is unknown, and we cannot return an empty support). *)
external vectorsupport : t array -> Bdd.t = \"camlidl_bdd_vectorsupport\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_VectorSupport}[Cudd_VectorSupport]}. Returns the support of the BDDs and RDDs arrays. 

Raises a [Failure] exception when both arrays are of size 0 (in such
case, the manager is unknown, and we cannot return an empty support). *)
external vectorsupport2 : Bdd.t array -> t array -> Bdd.t = \"camlidl_rdd_vectorsupport2\"
")

/* ====================================================================== */
/* Classical operations */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Classical operations} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addConst}[Cudd_addConst]}. Return a constant RDD with the given value. *)")
rdd__t cst(manager__t man, double val)
  quote(call, "_res.man = man; _res.node = Cudd_addConst(man,val);");

quote(MLI,"(** [Cuddaux_addIte]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addIte}[Cudd_addIte]}. If-then-else operation, with the condition being a BDD. *)")
rdd__t ite(bdd__t no1, rdd__t no2, rdd__t no3) NO_OF_MAN_NO123(Cuddaux_addIte);

quote(MLI,"(** [Cuddaux_addIteConstant]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addIteConstant}[Cudd_addIteConstant]}. If-then-else operation, which succeeds only if the resulting node belongs to one of the two RDD. *)")
[unique] rdd__t* ite_cst(bdd__t no1, rdd__t no2, rdd__t no3)
quote(call,
"  {
     static rdd__t res;
     DdNode* node;
     CHECK_MAN3;
     node = Cuddaux_addIteConstant(no1.man,no1.node,no2.node,no3.node);
     if (node==DD_NON_CONSTANT)
       _res = NULL;
     else {
       res.man = no1.man; 
       res.node = node;
       _res = &res;
     }
   }
");

quote(MLI,"(** [Cuddaux_addEvalConst]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addEvalConst}[Cudd_addEvalConst]}. *)")
[unique] rdd__t * eval_cst(rdd__t no1, bdd__t no2)
quote(call,
"  {
     static rdd__t res;
     DdNode* node;

     CHECK_MAN2;
     node = Cuddaux_addEvalConst(no1.man,no2.node,no1.node);
     if (node==DD_NON_CONSTANT)
       _res = 0;
     else {
       res.man = no1.man;
       res.node = node;
       _res = &res;
     }
   }
");

quote(MLI,"(** [Cuddaux_addCompose]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addCompose}[Cudd_addCompose]}. Substitutes the variable with the BDD in the RDD. *)")
rdd__t compose(int var, bdd__t no1, rdd__t no2)
     quote(call,"
CHECK_MAN2;
Begin_roots2(_v_no1,_v_no2);
_res.man = no1.man;
_res.node = Cuddaux_addCompose(no1.man, no2.node, no1.node, var);
End_roots();
");

quote(MLMLI,"\n
(** [Cuddaux_addVectorCompose]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addVectorCompose}[Cudd_addVectorCompose]}. Parallel substitution of every variable [var] present in the manager by the BDD [table.(var)] in the RDD. *)
external vectorcompose: bdd__t array -> rdd__t -> rdd__t = \"camlidl_rdd_vectorcompose\"
")

quote(ML,"let dummy = cst Manager.dummy (Manager.get_background Manager.dummy)")

/* ====================================================================== */
/* Variable Mapping */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Variable mapping} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** [Cuddaux_addVarMap]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_bddVarMap}[Cudd_bddVarMap]}. Permutes the variables as it has been specified with {!Manager.set_varmap}. *)")
rdd__t varmap(rdd__t no)
     quote(call, "
Begin_roots1(_v_no);
if (no.man->map == NULL){
  failwith(\"Rdd.varmap: empty table, Manager.set_varmap has not been called !\");
}
_res.man = no.man;
_res.node = Cuddaux_addVarMap(no.man,no.node);
End_roots();
");

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addPermute}[Cudd_addPermute]}. Permutes the variables as it is specified by
[permut] (same format as in {!Manager.set_varmap}). *)")
quote(MLMLI,"external permute : t -> int array -> t = \"camlidl_rdd_permute\"")

/* ====================================================================== */
/* Logical tests */
/* ====================================================================== */
quote(MLMLI,"")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Logical tests} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLMLI,"
(** Equality test *)
external is_equal: t -> t -> bool = \"camlidl_bdd_is_equal\"
(** Variation of {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_EquivDC}[Cudd_EquivDC]}. Are the two RDDs equal when the BDD (careset) is true ? *)
external is_equal_when: t -> t -> Bdd.t -> bool = \"camlidl_bdd_is_equal_when\"
")

quote(MLI,"(** Variation of [Cuddaux_addEvalConst]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addEvalConst}[Cudd_addEvalConst]}. Is the RDD constant when the BDD (careset) is true, and in this case what is its value ? *)")
[unique] double * is_eval_cst(rdd__t no1, bdd__t no2)
quote(call,
"  {
     static double storage;
     DdNode* node;

     CHECK_MAN2;
     node = Cuddaux_addEvalConst(no1.man,no2.node,no1.node);
     if (node==DD_NON_CONSTANT || ! cuddIsConstant(node))
       _res = 0;
     else {
       storage = cuddV(node);
       _res = &storage;
     }
   }
");

quote(MLI,"(** Is the result of [ite] constant, and if it is the case, what is its value ? *)")
[unique] double * is_ite_cst(bdd__t no1, rdd__t no2, rdd__t no3)
quote(call,
"  {
     static double storage;

     DdNode* node;
     CHECK_MAN3;
     node = Cuddaux_addIteConstant(no1.man,no1.node,no2.node,no3.node);
     if (node==DD_NON_CONSTANT || ! cuddIsConstant(node))
       _res = 0;
     else {
       storage = cuddV(node);
       _res = &storage;
     }
   }
");

/* ====================================================================== */
/* Structural information */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Structural information} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLMLI,"
(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_DagSize}[Cudd_DagSize]}. Size if the RDD as a graph (the number of nodes). *)
external size :  t -> int = \"camlidl_bdd_size\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_CountPath}[Cudd_CountPath]}. Number of paths in the RDD from the root to the leafs. *)
external nbpaths : t -> float = \"camlidl_bdd_nbpaths\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_CountMinterm}[Cudd_CountMinterm]}. Number of minterms  of the RDD knowing that it depends on the given number of variables. *)
external nbminterms : int -> t -> float = \"camlidl_bdd_nbminterms\"

(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_Density}[Cudd_Density]}. Density of the RDD, which is the ratio of the number of minterms to the number of nodes. The RDD is assumed to depend on [nvars] variables. *)
external density : int -> t -> float = \"camlidl_bdd_density\"
")

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_CountPathsToNonZero}[Cudd_CountPathsToNonZero]}. Number of paths in the RDD from the root to non-zero leaves. *)")
double nbnonzeropaths(rdd__t no)
quote(call,
"_res = Cudd_CountPathsToNonZero(no.node); \
if (_res==(double)CUDD_OUT_OF_MEM){ \
  failwith(\"Bdd.nbnonzeropaths returned CUDD_OUT_OF_MEM\"); \
}");

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_CountLeaves}[Cudd_CountLeaves]}. Number of leaves. *)")
int nbleaves(rdd__t no)
quote(call,
"_res = Cudd_CountLeaves(no.node); \
if (_res==CUDD_OUT_OF_MEM){ \
  failwith (\"Rdd.nbleaves returned CUDD_OUT_OF_MEM\"); \
}");

/* ====================================================================== */
/* Iterators */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Iterators} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLMLI, "
(** Similar to {!Bdd.iter_node} *)
external iter_node: (t -> unit) -> t -> unit = \"camlidl_cudd_iter_node\"

(** Similar to {!Bdd.iter_cube} *)
external iter_cube: (Manager.tbool array -> float -> unit) -> t -> unit = \"camlidl_rdd_iter_cube\"
")

/* ====================================================================== */
/* Leaves and guards */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Leaves and guards} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** [Cuddaux_addGuardOfNode]. [guard_of_node f node] returns the sum of the paths leading from the root node [f] to the node [node] of [f]. *)")
bdd__t guard_of_node(rdd__t no1, rdd__t no2) NO_OF_MAN_NO12(Cuddaux_addGuardOfNode);
quote(MLI,"(** Guard of non background leaves *)")
bdd__t guard_of_nonbackground(rdd__t no)
     quote(call,"
Begin_roots1(_v_no);
{
  DdNode* add = Cudd_ReadBackground(no.man);
  cuddRef(add);
  _res.man = no.man;
  _res.node = Cuddaux_addGuardOfNode(no.man,no.node,add);
  _res.node = Cudd_Not(_res.node);
  cuddDeref(add);
}
End_roots();
");

quote(MLI,"(** Guard of the given leaf *)")
bdd__t guard_of_leaf(rdd__t no, double val)
     quote(call,"
Begin_roots1(_v_no);
{
DdNode* nval = Cudd_addConst(no.man, val);
cuddRef(nval);
_res.man = no.man;
_res.node = Cuddaux_addGuardOfNode(no.man,no.node,nval);
cuddDeref(nval);
}
End_roots();
");

quote(MLMLI,"
(** [Cuddaux_NodesBelowLevel]. [nodes_below_level f olevel] returns all the nodes pointed by the RDD, indexed by a variable of level greater or equal than [level], and encountered first in the top-down exploration (i.e., whenever a node is collected, its sons are not collected). If [olevel=None], then only constant nodes are collected. *)
external nodes_below_level: t -> int option -> t array = \"camlidl_rdd_nodes_below_level\"

(** Returns the set of leaf values (including the background value if adequate) *)
external leaves: t -> float array = \"camlidl_rdd_leaves\"
")
quote(MLI,"
\n
(** Returns the set of leaf values together with their guard in the RDD *)
val guardleafs : t -> (Bdd.t * float) array
")
quote(ML,"
let guardleafs rdd =
  let tab = leaves rdd in
  Array.map (fun leaf -> (guard_of_leaf rdd leaf,leaf)) tab
")

/* ====================================================================== */
/* Minimizations */
/* ====================================================================== */
quote(MLMLI,"")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Minimizations} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** See {!Bdd.constrain}, {!Bdd.tdconstrain}, {!Bdd.restrict}, {!Bdd.tdrestrict} *)\n")

rdd__t constrain(rdd__t no1, bdd__t no2) NO_OF_MAN_NO12(Cuddaux_addConstrain);
rdd__t tdconstrain(rdd__t no1, bdd__t no2) NO_OF_MAN_NO12(Cuddaux_addTDConstrain);
rdd__t restrict(rdd__t no1, bdd__t no2) NO_OF_MAN_NO12(Cuddaux_addRestrict);
rdd__t tdrestrict(rdd__t no1, bdd__t no2) NO_OF_MAN_NO12(Cuddaux_addTDRestrict);

/* ====================================================================== */
/* Conversions */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Conversions} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_BddToAdd}[Cudd_BddToAdd]}. Conversion from BDD to 0-1 RDD *)")
rdd__t of_bdd(bdd__t no) NO_OF_MAN_NO(Cudd_BddToAdd);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addBddPattern}[Cudd_addBddPattern]}. Conversion from RDD to BDD by replacing all leaves different from 0  by true. *)")
bdd__t to_bdd(rdd__t no) NO_OF_MAN_NO(Cudd_addBddPattern);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addBddThreshold}[Cudd_addBddThreshold]}. Conversion from RDD to BDD by replacing all leaves greater than or equal to the threshold by true. *)")
rdd__t to_bdd_threshold(double val, rdd__t no)
     quote(call,"
Begin_roots1(_v_no);
_res.man = no.man;
_res.node = Cudd_addBddThreshold(no.man,no.node,val);
End_roots();
");

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addBddStrictThreshold}[Cudd_addBddStrictThreshold]}. Conversion from RDD to BDD by replacing all leaves strictly greater than the threshold by true.*)")
rdd__t to_bdd_strictthreshold(double val, rdd__t no)
     quote(call,"
Begin_roots1(_v_no);
_res.man = no.man;
_res.node = Cudd_addBddStrictThreshold(no.man,no.node,val);
End_roots();
");

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addBddInterval}[Cudd_addBddInterval]}. Conversion from RDD to BDD  by replacing all leaves in the interval by true. *)")
rdd__t to_bdd_interval(double lower, double upper, rdd__t no)
     quote(call,"
Begin_roots1(_v_no);
_res.man = no.man;
_res.node = Cudd_addBddInterval(no.man,no.node,lower,upper);
End_roots();
");

/* ====================================================================== */
/* Quantifications */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Quantifications} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** Variation of {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addExistAbstract}[Cudd_addExistAbstract]}. Abstracts all the variables in the cube from the RDD by summing over all possible values taken by those variables. *)")
rdd__t exist(bdd__t no1, rdd__t no2)
     quote(call,"
CHECK_MAN2();
Begin_roots2(_v_no1,_v_no2);
{
   DdNode* add1 = Cudd_BddToAdd(no1.man,no1.node);
  cuddRef(add1);
  _res.man = no1.man;
  _res.node = Cudd_addExistAbstract(no1.man,no2.node,add1);
  cuddRef(_res.node);
  Cudd_RecursiveDeref(no1.man,add1);
  cuddDeref(_res.node);
}
End_roots();
");

quote(MLI,"(** Variation of {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addUnivAbstract}[Cudd_addUnivAbstract]}. Abstracts all the variables in the cube from the RDD by taking the product over all possible values taken by those variables. *)")
rdd__t forall(bdd__t no1, rdd__t no2)
     quote(call,"
CHECK_MAN2();
Begin_roots2(_v_no1,_v_no2);
{
  DdNode* add1 = Cudd_BddToAdd(no1.man,no1.node);
  cuddRef(add1);
  _res.man = no1.man;
  _res.node = Cudd_addUnivAbstract(no1.man,no2.node,add1);
  cuddRef(_res.node);
  Cudd_RecursiveDeref(no1.man,add1);
  cuddDeref(_res.node);
}
End_roots();
");

/*
rdd__t exist(bdd__t no1, rdd__t no2)
     NO_OF_MAN_NO21(Cudd_addExistAbstract);
rdd__t forall(bdd__t no1, rdd__t no2)
     NO_OF_MAN_NO21(Cudd_addUnivAbstract);
*/

/* ====================================================================== */
/* Algebraic operations */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Algebraic operations} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html# Cudd_addLeq}[ Cudd_addLeq]}. *)")
boolean is_leq(rdd__t no1, rdd__t no2)
  quote(call, "CHECK_MAN2; _res = Cudd_addLeq(no1.man,no1.node,no2.node);");

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addPlus}[Cudd_addPlus]}. *)")
rdd__t add(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addPlus);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addMinus}[Cudd_addMinus]}. *)")
rdd__t sub(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addMinus);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addTimes}[Cudd_addTimes]}. *)")
rdd__t mul(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addTimes);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addDivide}[Cudd_addDivide]}. *)")
rdd__t div(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addDivide);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addMinimum}[Cudd_addMinimum]}. *)")
rdd__t min(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addMinimum);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addMaximum}[Cudd_addMaximum]}. *)")
rdd__t max(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addMaximum);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addAgreement}[Cudd_addAgreement]}. *)")
rdd__t agreement(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addAgreement);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addDiff}[Cudd_addDiff]}. *)")
rdd__t diff(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addDiff);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addThreshold}[Cudd_addThreshold]}. *)")
rdd__t threshold(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addThreshold);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addSetNZ}[Cudd_addSetNZ]}. *)")
rdd__t setNZ(rdd__t no1, rdd__t no2) APPLYBINOP(Cudd_addSetNZ);

quote(MLI,"(** {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addLog}[Cudd_addLog]}. *)")
rdd__t log(rdd__t no) APPLYUNOP(Cudd_addLog);

/* ====================================================================== */
/* Matrix Operations */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Matrix operations} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLMLI,"
(** Variation of {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addMatrixMultiply}[Cudd_addMatrixMultiply]}.

[matrix_multiply z A B] performs matrix multiplication of [A] and [B], with [z]
being the summation variables, which means that they are used to refer columns
of [A] and to rows of [B]. *)
external matrix_multiply : int array -> t -> t -> t = \"camlidl_rdd_matrix_multiply\"

(** Variation of {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addTimesPlus}[Cudd_addTimesPlus]}. *)
external times_plus : int array -> t -> t -> t = \"camlidl_rdd_times_plus\"

(** Variation of {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addTriangle}[Cudd_addTriangle]}. *)
external triangle : int array -> t -> t -> t = \"camlidl_rdd_triangle\"
")
quote(C,"
MATMUL(camlidl_rdd_matrix_multiply,Cudd_addMatrixMultiply)
MATMUL(camlidl_rdd_times_plus,Cudd_addTimesPlus)
MATMUL(camlidl_rdd_triangle,Cudd_addTriangle)
")

/* ====================================================================== */
/* User Operations */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 User operations} *)")
quote(MLMLI,"(*  ====================================================== *)")

quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {3 By decomposition into guards and leaves} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"(**
Be cautious: here the background leaf is used as a special value,
and should not be used for ordinary purpose.
*)")

quote(MLI,"
val mapleaf1 : (Bdd.t -> float -> float) -> t -> t
val mapleaf2 : (Bdd.t -> float -> float -> float) -> t -> t -> t
")
quote(ML,"
let mapleaf1
  (f:Bdd.t -> float -> float)
  (rdd:t)
  :
  t
  =
  let manager = manager rdd in
  let background = Manager.get_background manager in
  let leaves = leaves rdd in
  let res = ref (cst manager background) in
  for i=0 to pred (Array.length leaves) do
    let leaf = leaves.(i) in
    if leaf<>background then begin
      let guard = guard_of_leaf rdd leaves.(i) in
      let nleaf = f guard leaf in
      res := ite guard (cst manager nleaf) !res
    end
  done;
  !res

let mapleaf2
  (f:Bdd.t -> float -> float -> float)
  (rdd1:t)
  (rdd2:t)
  :
  t
  =
  let manager = manager rdd1 in
  let background = Manager.get_background manager in
  let ddbackground = cst manager background in
  let leaves1 = leaves rdd1 in
  let res = ref ddbackground in
  for i1=0 to pred (Array.length leaves1) do
    let leaf1 = leaves1.(i1) in
    if leaf1<>background then begin
      let guard1 = guard_of_leaf rdd1 leaf1 in
      let rdd2 = ite guard1 rdd2 ddbackground in
      let leaves2 = leaves rdd2 in
      for i2=0 to pred (Array.length leaves2) do
	let leaf2 = leaves2.(i2) in
	if leaf2<>background then begin
	  let guard2 = guard_of_leaf rdd2 leaf2 in
	  let nleaf = f guard2 leaf1 leaf2 in
	  res := ite guard2 (cst manager nleaf) !res
	end
      done
    end
  done;
  !res
")

quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {3 By using CUDD local cache (efficient and flexible)} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLI,"
val mapunop : (float -> float) -> t -> t
val mapbinop : commutative:bool -> (float -> float -> float) -> t -> t -> t
val mapterop : (float -> float -> float -> float) -> t -> t -> t -> t
")
quote(ML,"
external _internal_mapunop : bool -> (float -> float) -> t -> t = \"camlidl_rddidd_mapunop\"
external _internal_mapbinop : bool -> bool -> (float -> float -> float) -> t -> t -> t = \"camlidl_rddidd_mapbinop\"
external _internal_mapterop : bool -> (float -> float -> float -> float) -> t -> t -> t -> t = \"camlidl_rddidd_mapterop\"
let mapunop f t = _internal_mapunop false f t
let mapbinop ~commutative f t1 t2 = _internal_mapbinop false commutative f t1 t2
let mapterop f t1 t2 t3 = _internal_mapterop false f t1 t2 t3
")

/*
quote(MLMLI,"
external applyunop : (t -> t option) -> t -> t = \"camlidl_rdd_applyunop\"
external applybinop : (t -> t -> t option) -> t -> t -> t = \"camlidl_rdd_applybinop\"
external applyterop : (t -> t -> t -> t option) -> t -> t -> t = \"camlidl_rdd_applyterop\"
")
*/

quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {3 By using CUDD global cache (more efficient, less flexible)} *)")
quote(MLMLI,"(* ====================================================== *)")


quote(MLMLI,"
external alloc_unop: (float -> float) -> id_unop = \"camlidl_rdd_alloc_unop\"
external alloc_binop: (float -> float -> float) -> id_binop = \"camlidl_rdd_alloc_binop\"
external alloc_combinop: (float -> float -> float) -> id_combinop = \"camlidl_rdd_alloc_combinop\"
(** Registers operations on leaves and returns their identification number
(which is an abstract datatype). Possible types of operations are unary
operations, binary operations and commutative binary operations. *)

external apply_unop: id_binop -> t -> t = \"camlidl_rdd_apply_unop\"
external apply_binop: id_binop -> t -> t -> t = \"camlidl_rdd_apply_binop\"
external apply_combinop: id_combinop -> t -> t -> t = \"camlidl_rdd_apply_combinop\"
(** Applies the given operations (initially defined on leaf values) to RDDs, by
using
{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addMonadicApply}[Cudd_addMonadicApply]}
or
{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_addApply}[Cudd_addApply]}. *)
")
quote(C,"ALLOCAPPLY_USEROP(rdd,copy_double,Double_val)")

/* ====================================================================== */
/* Miscellaneous */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Miscellaneous} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLI,"(** [Cuddaux_addTransfer]/{{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_bddTransfer}[Cudd_bddTransfer]}. Transfers a RDD to a different manager. *)")
rdd__t transfer(rdd__t no, manager__t man)
     quote(call, "
Begin_roots1(_v_no);
_res.man = man;
_res.node = Cuddaux_addTransfer(no.man,man,no.node);
End_roots();
");

/* ====================================================================== */
/* Printing */
/* ====================================================================== */
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"(** {2 Printing} *)")
quote(MLMLI,"(*  ====================================================== *)")
quote(MLMLI,"")

quote(MLMLI,"
(** C printing function. The output may mix badly with the OCaml output. *)
external _print: t -> unit = \"camlidl_cudd_print\"
")

quote(MLI,"
(** Prints the minterms of the BDD in the same way as {{:http://vlsi.colorado.edu/~fabio/CUDD/cuddExtDet.html#Cudd_Printminterm}[Cudd_Printminterm]}. *)
val print__minterm: Format.formatter -> t -> unit

(** [print_minterm bassoc fmt bdd] prints the minterms of the BDD using [bassoc] to convert indices of variables to names qand [lassoc] to convert leaf values to strings. *)
val print_minterm: (int -> string) -> (float -> string) -> Format.formatter -> t -> unit

(** Prints a BDD by recursively decomposing it as monomial followed by a tree. *)
val print: (int -> string) -> (float -> string) -> Format.formatter -> t -> unit
")


quote(ML,"
open Format

let print__minterm fmt rdd =
  if is_cst rdd then pp_print_float fmt (dval rdd)
  else
    let nb = nbpaths rdd in
    if nb > (float_of_int !Manager.print_limit) then
      fprintf fmt \"rdd with %i nodes, %i leaves and %g paths\" (size rdd) (nbleaves rdd) nb
  else begin
    fprintf fmt \"@[<v>\";
    let first = ref true in
    iter_cube
      (begin fun cube leaf ->
	if not !first then fprintf fmt \"@ \" else first := false;
	let str = String.create (Array.length cube) in
	Array.iteri
	  (begin fun i elt ->
	    str.[i] <-
	      begin match elt with
	      | Manager.False -> '0'
	      | Manager.True -> '1'
	      | Manager.Top -> '-'
	      end
	  end)
	  cube;
	fprintf fmt \"%s -> %g\" str leaf
      end)
      rdd;
    fprintf fmt \"@]\"
  end

let print_minterm bassoc nassoc fmt rdd =
  if is_cst rdd then pp_print_string fmt (nassoc (dval rdd))
  else
    let nb = nbpaths rdd in
    if nb > (float_of_int !Manager.print_limit) then
      fprintf fmt \"rdd with %i nodes, %i leaves and %g paths\" (size rdd) (nbleaves rdd) nb
  else begin
    let leaves = leaves rdd in
    fprintf fmt \"{ @[<v>\";
    for i=Array.length leaves - 1 downto 0 do
      let leaf = leaves.(i) in
      let bdd = guard_of_leaf rdd leaf in
      fprintf fmt \"%s IF %a\"
	(nassoc leaf) (Bdd.print_minterm bassoc) bdd;
      if i > 0 then
	fprintf fmt \",@ \";
    done;
    fprintf fmt \"@] }\"
  end

let rec print bassoc nassoc formatter rdd =
  match inspect rdd with
  | Leaf(v) -> pp_print_string formatter (nassoc v)
  | Ite(var,alors,sinon) ->
      fprintf formatter \"ITE(@[<hv>%s;@,%a;@,%a)@]\"
	(bassoc var) (print bassoc nassoc) alors (print bassoc nassoc) sinon
")
