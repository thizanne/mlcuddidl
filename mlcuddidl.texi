\input texinfo @c -*-texinfo-*-

@c %**start of header
@setfilename mlcuddidl.info
@setcontentsaftertitlepage
@c include version.texi
@iftex
@afourpaper
@end iftex
@comment %**end of header

@tex
\global\parskip=0.5ex
\global\baselineskip=3ex
@end tex

@direntry
* mlcuddidl: (mlcuddidl).                   OCaml interface for CUDD and CUDDAUX.
@end direntry

@iftex
@finalout
@end iftex

@setchapternewpage even

@c Texinfo version 4 or up will be needed to process this into .info files.
@c
@c The edition number is in three places and the month/year in one, all
@c taken from version.texi.  version.texi is created when you configure with
@c --enable-maintainer-mode, and is included in a distribution made with
@c "make dist".

@titlepage
@c  use the new format for titles

@title MLCUDDIDL
@subtitle OCaml Interface for CUDD and CUDDAUX
@subtitle Edition 1.0, 14 May 2002
@author by Bertrand Jeannet
@c Include the Distribution inside the titlepage so
@c that headings are turned off.
@end titlepage

@ifnottex
This manual documents how to install and use the MLCUDDIDL interface to the BDD library CUDD. @value{VERSION}.
@node Top, Introduction, (dir), (dir)
@top mlcuddidl
@end ifnottex

@menu
* Introduction::                
* Manager::                     
* Bdd::                         
* Rdd::                         
* Idd::                         
* Mtbdd::                       
* Appendices::                  
@end menu

@c *******************************************************************
@node Introduction, Manager, Top, Top
@chapter Introduction
@c *******************************************************************

This library provides an @sc{OCaml} interface to
the BDD's library @sc{C}. The reader is supposed to have first
read the user's manual of this library.

Many but not all functions of the @sc{Cudd} library are interfaced; in
particular, there is no interface for @sc{Zdd}s.


@c ===================================================================
@section Organization of the interface
@c ===================================================================

The interface is decomposed in the following modules (each module
corresponding to a file):
@itemize @bullet
@item 
@code{Manager} defines operations on @sc{Cudd} managers: creation,
parameters settings, statistics, order, ...
@item 
@code{Bdd} defines operations on @sc{Bdd}s.
@item
@code{Rdd} defines operations on @sc{Mtbdd}s, the leaves of which are
real numbers. These corresponds to the @sc{Add}s of @sc{Cudd}. We used
@code{R} instead to precise that leaves are @emph{real} numbers.
@item
@code{Idd} defines operations on @sc{Mtbdd}s, the leaves of which are
integer numbers (i.e., @sc{Cudd} @sc{Add}s with integer leaves). The
main purpose of this module is to serve as a basis to implement
@sc{MTBdd}s.
@item
@code{Mtbdd} allows to define @sc{Mtbdds} in which the type of the
leaves can be any @sc{OCaml} datatype. The module actually defines a
functor which takes as input module a module defining a datatype and
which return a new module to manipulate @sc{MTBdd}s in which terminal
nodes are of the given datatype.
@end itemize

@c ===================================================================
@section Memory management
@c ===================================================================

The diagrams are implemented as abstract types, and more precisely as
@sc{OCaml} @emph{custom objects}. These objects contain both the manager
which owns the diagram and the diagram itself. They are garbage
collected by the @sc{OCaml} garbage collection. The effect of the
@sc{OCaml} garbage collection is to decrease the reference count of the
diagram if it has become unreachable from the @sc{OCaml} heap, and to
remove the @sc{OCaml} custom object from the @sc{OCaml} heap. Later, the
@sc{Cudd} may possibly garbage the diagram in the C heap, if its
reference count is zero.

For efficiency reasons, it is better to link in some way the two garbage
collectors. So, when the @sc{Cudd} garbage collector is triggered, in a
normal situation (during the creation of a new node) or because of a
reordering operation, it first calls the @sc{OCaml} garbage collector,
in order to be able to garbage collect as many nodes as possible.

The function @code{Manager.set_gc} allows to tune the @sc{OCaml} garbage
collection of diagrams and the link with the @sc{Cudd} garbage
collection.

It is possible to apply to the diagrams the polymorphic comparison test
(@code{Pervasives.compare}, from which are derived @code{=,<=,>=,<,>})
and polymorphic hash function (polymorphic @code{hashtbl.hash}). The comparison
function compares lexicographically the pair @code{address of the
manager, address of the node}). The hash function returns the address of
the node.

@c ===================================================================
@section This document
@c ===================================================================

Each module is described separately. For each @sc{Ocaml} function, we
indicate below in typewriter font the @sc{Cudd} function to which it
corresponds, whenever possible. If the order of the arguments has been
changed, we usually specify ``variation of'' before.

We do not describe in detail the functions which have a direct @sc{Cudd}
equivalent. Instead, we refer the user to the original @sc{Cudd}
documentation.

@c ===================================================================
@section Organization of the code
@c ===================================================================

The interface has been written with the help of the @sc{CamlIDL} tool,
the input files of which are suffixed with @file{.idl}. @sc{CamlIDL}
automizes most of the cumbersome task of writing stub codes and
converting datatypes back and forth between C and @sc{OCaml}. However,
as we implemented more than a direct interface, we also used the
@sc{M4} preprocessor on @file{.idl} files to simplify the task
(instead of the default @sc{cpp} C preprocessor).

@file{.idl} files are thus filtered through @sc{M4} and
transformed according to the macro file @file{macros.m4}, then
@sc{CamlIDL} generates from them four files, suffixed with @file{.c},
@file{.h}, @file{.ml} and @file{.mli}.

@file{cudd_caml.c} and @file{cudd_caml.h} are not generated from a
@file{.idl} file and contain code common to all the other files.
@file{mtbdd.ml} and @file{mtbdd.mli} are also not generated from a
@file{.idl} file.

The normal user doesn't need to understand this process, as the
library is distributed with all the C and @sc{OCaml} files already
generated.

@c ===================================================================
@section Tools needed and/or used for the interface
@c ===================================================================

@noindent Needed:
@table @emph
@item GNU Make
@uref{http://www.gnu.org/software/make}
@item CUDD BDD library
@uref{http://vlsi.colorado.edu/software.html}
@item CUDDAUX extension library
@uref{http://www.irisa.fr/prive/bjeannet/mlcuddidl.html}
@item OBJECTIVE CAML 3.0
@uref{http://caml.inria.fr}
@item CAMLIDL 1.04
@uref{http://caml.inria.fr/camlidl}
@end table

@noindent Optional:
@table @strong
@item M4 preprocessor, SED, GREP 
GNU version: @uref{http://www.gnu.org/software}
@item TEXINFO documentation system
@uref{http://texinfo.org/}
@end table

@c ===================================================================
@section Installation and Use
@c ===================================================================

Flags should be properly set at the beginning of the Makefile.

Also, the Make rules for some @file{dummy.ml} file shows how to compile 
a program with the interface.

@c *******************************************************************
@node Manager, Bdd, Introduction, Top
@chapter Manager
@c *******************************************************************

@menu
* Global settings::             
* Manager types::               
* Manager management::          
* Variables and Reordering and Mapping::  
* Parameters::                  
* Statistics::                  
@end menu

@c ===================================================================
@node Global settings, Manager types, Manager, Manager
@section Global settings
@c ===================================================================
@defvar print_limit @t{: int ref}
Parameter for printing functions: specify the maximum number of
minterms to be printed. Above this numbers, only statistics on the
@sc{Bdd} is printed.
@end defvar

@defun set_gc @t{max:int -> gc:(unit -> unit) -> reordering:(unit -> unit) -> unit}
The function first sets the ratio used/max for @sc{Bdd}s abstract
values to  @code{1/max} (see the @sc{OCaml} manual for details). 1 000
000 is a good value. 

@noindent
It also sets for all the future managers that will be created the hook
function to be called before a @sc{Cudd} garbage collection, and the
hook function to be called before a @sc{Cudd} reordering. You may
typically specify a @sc{OCaml} garbage collection function for both
hooks, in order to make @sc{OCaml} dereference unused nodes, thus
allowing @sc{Cudd} to remove them. Default values are
@code{Gc.full_major()} for both hooks.
@end defun

@c ===================================================================
@node Manager types, Manager management, Global settings, Manager
@section Manager types
@c ===================================================================

@deftp Datatype t
Abstract datatype for managers. There is no automatic garbage
collection for this type, since @sc{Bdd}s abstract values references
them. They must be explictly freed if this is necessary with the
function @code{free} (see below).
@end deftp
@defvar dummy @t{: t}
``Dummy'' objet of type @code{t}. It can be practical to put default
values before initialization in an object. @code{dummy} refers to a
real manager, but it is created with tiny memory constraints: don't
use it !
@end defvar

@deftp Datatype reorder
Type to specify the reordering method. Names corresponds to the names
used in the @sc{Cudd} library (with the prefix @code{CUDD_} removed).
@display
type reorder =
  | REORDER_SAME
  | REORDER_NONE
  | REORDER_RANDOM
  | REORDER_RANDOM_PIVOT
  | REORDER_SIFT
  | REORDER_SIFT_CONVERGE
  | REORDER_SYMM_SIFT
  | REORDER_SYMM_SIFT_CONV
  | REORDER_WINDOW2
  | REORDER_WINDOW3
  | REORDER_WINDOW4
  | REORDER_WINDOW2_CONV
  | REORDER_WINDOW3_CONV
  | REORDER_WINDOW4_CONV
  | REORDER_GROUP_SIFT
  | REORDER_GROUP_SIFT_CONV
  | REORDER_ANNEALING
  | REORDER_GENETIC
  | REORDER_LINEAR
  | REORDER_LINEAR_CONVERGE
  | REORDER_LAZY_SIFT
  | REORDER_EXACT
@end display
@end deftp

@deftp Datatype aggregation
Type to specify the aggregation method.
@display
type aggregation =
  | NO_CHECK
  | GROUP_CHECK
  | GROUP_CHECK2
  | GROUP_CHECK3
  | GROUP_CHECK4
  | GROUP_CHECK5
  | GROUP_CHECK6
  | GROUP_CHECK7
  | GROUP_CHECK8
  | GROUP_CHECK9
@end display
@end deftp

@deftp Datatype lazygroup
@display
type lazygroup =
  | LAZY_NONE
  | LAZY_SOFT_GROUP
  | LAZY_HARD_GROUP
  | LAZY_UNGROUP
@end display
@end deftp

@deftp Datatype vartype
@display
type vartype =
  | VAR_PRIMARY_INPUT
  | VAR_PRESENT_STATE
  | VAR_NEXT_STATE
@end display
@end deftp

@deftp Datatype mtr
To specify grouping of variables in reordering.
@display
type mtr =
  | MTR_DEFAULT
  | MTR_FIXED
@end display
@end deftp

@deftp Datatype error
@sc{Cudd} error code. It can be consulted with @code{get_error}.
@display
type error =
  | NO_ERROR
  | MEMORY_OUT
  | TOO_MANY_NODES
  | MAX_MEM_EXCEEDED
  | INVALID_ARG
  | INTERNAL_ERROR
@end display
@end deftp

@deftp Datatype tbool
@display
type tbool = False | True | Top
@end display
Ternary Boolean type, used to defines minterms where @code{Top}
means @code{True or False}.
@display
@end display
@end deftp

@c ===================================================================
@node Manager management, Variables and Reordering and Mapping, Manager types, Manager
@section Manager management
@c ===================================================================



@defun make @t{: numVars:int -> numVarsZ:int -> numSlots:int -> cacheSize:int -> maxMemory:int -> t}
@code{Cudd_Init}@*
In addition, the function sets a hook function to be called whenever a
@sc{Cudd} garbage collection occurs, and a hook function to be called
whenever a @sc{Cudd} reordering occurs. The defaults can be modified
with @t{set_gc}.
@end defun 

@defun free @t{: t -> unit}
Frees the manager @code{man}. DANGEROUS AND UNSAFE OPERATION: you need to be sure that there is no BDDs any more that refers to this manager and that haven't been yet reclaimed by the garbage collector. Be sure that there is no BDDs left in your reachable data, and call first @code{Gc.full_major()}.
@end defun

@defun debugcheck @t{: t -> bool}
@code{Cudd_DebugCheck}@* 
Returns @code{false} if it is OK, @code{true} if there is a problem,
and throw a @code{Failure} exception in case of
@code{CUDD_OUT_OF_MEM}.
@end defun

@defun check_keys @t{: t -> int}
@code{Cudd_CheckKeys}
@end defun


@c ===================================================================
@node Variables and Reordering and Mapping, Parameters, Manager management, Manager
@section Variables and Reordering and Mapping
@c ===================================================================

@defun level_of_var @t{: t -> var:int -> int}
@defunx var_of_level @t{: t -> level:int -> int}
@code{Cudd_ReadPerm} @code{Cudd_ReadInvPerm}@*
Correspondance between variables (defined by an index) and levels in @sc{Bdd}s.
@end defun
@defun reduce_heap @t{: t -> reorder -> minsize:int -> unit}
@code{Cudd_ReduceHeap}
@end defun
@defun shuffle_heap @t{: t -> int array -> unit}
@code{Cudd_ShuffleHeap}
@end defun

@defun enable_autodyn @t{: t -> reorder -> unit}
@defunx disable_autodyn @t{: t -> unit}
@code{Cudd_AutodynEnable} @code{Cudd_AutodynDisable}@*
Enable/disable automatic variabe reordering.
@end defun
@defun autodyn_status @t{: t -> bool}
@code{Cudd_ReorderingStatus}
@end defun
@defun group @t{: t -> low:int -> size:int -> type:mtr -> unit}
@code{Cudd_MakeTreeNode}
@end defun
@defun set_varmap @t{: t -> int array -> unit}
@code{Cuddaux_SetVarMap}
@end defun

@c ===================================================================
@node Parameters, Statistics, Variables and Reordering and Mapping, Manager
@section Variables and Reordering and Mapping
@c ===================================================================

@c -------------------------------------------------------------------
@subsection RDDs
@c -------------------------------------------------------------------
@defun get_background @t{: t -> double}
@defunx set_background @t{: t -> double -> unit}
@code{Cudd_ReadBackground} @code{Cudd_SetBackground}@* 
The interface is a bit changed: a double should be specified or
returned instead of a constant node.
@end defun
@defun get_epsilon @t{: t -> double}
@defunx set_epsilon @t{: t -> double -> unit}
@code{Cudd_ReadEpsilon} @code{Cudd_SetEpsilon}
@end defun


@c -------------------------------------------------------------------
@subsection Cache related
@c -------------------------------------------------------------------
@defun get_min_hit @t{: t -> int}
@defunx set_min_hit @t{: t -> int -> unit}
@code{Cudd_ReadMinHit} @code{Cudd_SetMinHit}
@end defun
@defun get_max_cache_hard @t{: t -> int}
@defunx set_max_cache_hard @t{: t -> int -> unit}
@code{Cudd_ReadMaxCacheHard} @code{Cudd_SetMaxCacheHard}
@end defun

@c -------------------------------------------------------------------
@subsection Manager
@c -------------------------------------------------------------------

@defun get_looseupto @t{: t -> int}
@defunx set_looseupto @t{: t -> int -> unit}
@code{Cudd_ReadLooseUpTo} @code{Cudd_SetLooseUpTo}
@end defun
@defun get_max_live @t{: t -> int}
@defunx set_max_live @t{: t -> int -> unit}
@code{Cudd_ReadMaxLive} @code{Cudd_SetMaxLive}
@end defun
@defun get_max_mem @t{: t -> int}
@defunx set_max_mem @t{: t -> int -> unit}
@code{Cudd_ReadMaxMemory} @code{Cudd_SetMaxMemory}
@end defun

@c -------------------------------------------------------------------
@subsection Reordering methods
@c -------------------------------------------------------------------
@defun get_sift_max_swap @t{: t -> int}
@defunx set_sift_max_swap @t{: t -> int -> unit}
@code{Cudd_ReadSiftMaxSwap} @code{Cudd_SetSiftMaxSwap}
@end defun
@defun get_sift_max_var @t{: t -> int}
@defunx set_sift_max_var @t{: t -> int -> unit}
@code{Cudd_ReadSiftMaxVar} @code{Cudd_SetSiftMaxVar}
@end defun
@defun get_groupcheck @t{: t -> aggregation}
@defunx set_groupcheck @t{: t -> aggregation -> unit}
@code{Cudd_ReadGroupcheck} @code{Cudd_SetGroupcheck}
@end defun
@defun get_arcviolation @t{: t -> int}
@defunx set_arcviolation @t{: t -> int -> unit}
@code{Cudd_ReadArcviolation} @code{Cudd_SetArcviolation}
@end defun
@defun get_crossovers @t{: t -> int}
@defunx set_crossovers @t{: t -> int -> unit}
@code{Cudd_ReadNumberXovers} @code{Cudd_SetNumberXovers}
@end defun
@defun get_population @t{: t -> int}
@defunx set_population @t{: t -> int -> unit}
@code{Cudd_ReadPopulationSize} @code{Cudd_SetPopulationSize}
@end defun
@defun get_recomb @t{: t -> int}
@defunx set_recomb @t{: t -> int -> unit}
@code{Cudd_ReadRecomb} @code{Cudd_SetRecomb}
@end defun
@defun get_symmviolation @t{: t -> int}
@defunx set_symmviolation @t{: t -> int -> unit}
@code{Cudd_ReadSymmviolation} @code{Cudd_SetSymmviolation}
@end defun

@c -------------------------------------------------------------------
@subsection Dynamic reordering
@c -------------------------------------------------------------------
@defun get_max_growth @t{: t -> double}
@defunx set_max_growth @t{: t -> double -> unit}
@code{Cudd_ReadMaxGrowth} @code{Cudd_SetMaxGrowth}
@end defun
@defun get_max_growth_alt @t{: t -> double}
@defunx set_max_growth_alt @t{: t -> double -> unit}
@code{Cudd_ReadMaxGrowthAlternate} @code{Cudd_SetMaxGrowthAlternate}
@end defun
@defun get_reordering_cycle @t{: t -> int}
@defunx set_reordering_cycle @t{: t -> int -> unit}
@code{Cudd_ReadReorderingCycle} @code{Cudd_SetReorderingCycle}
@end defun
@defun get_next_autodyn @t{: t -> int}
@defunx set_next_autodyn @t{: t -> int -> unit}
@code{Cudd_ReadNextReordering} @code{Cudd_SetNextReordering}
@end defun


@c ===================================================================
@node Statistics,  , Parameters, Manager
@section Statistics
@c ===================================================================

@defun get_cache_hits @t{: t -> double}
@code{Cudd_ReadCacheHits}
@end defun
@defun get_cache_lookups @t{: t -> double}
@code{Cudd_ReadCacheLookUps}
@end defun
@defun get_cache_slots @t{: t -> int}
@code{Cudd_ReadCacheSlots}
@end defun
@defun get_cache_used_slots @t{: t -> double}
@code{Cudd_ReadCacheUsedSlots}
@end defun
@defun get_dead @t{: t -> int}
@code{Cudd_ReadDead}
@end defun
@defun get_error @t{: t -> error}
@code{Cudd_ReadErrorCode}
@end defun
@defun get_gc_time @t{: t -> int}
@code{Cudd_ReadGarbageCollectionTime}
@end defun
@defun get_gc_nb @t{: t -> int}
@code{Cudd_ReadGarbageCollections}
@end defun
@defun get_keys @t{: t -> int}
@code{Cudd_ReadKeys}
@end defun
@defun get_linear @t{: t -> row:int -> col:int -> int}
@code{Cudd_ReadLinear}
@end defun
@defun get_max_cache @t{: t -> int}
@code{Cudd_ReadMaxCache}
@end defun
@defun get_min_dead @t{: t -> int}
@code{Cudd_ReadMinDead}
@end defun
@defun get_node_count @t{: t -> int}
@code{Cudd_ReadNodeCount}
@end defun
@defun get_node_count_peak @t{: t -> int}
@code{Cudd_ReadPeakNodeCount}
@end defun
@defun get_reordering_time @t{: t -> int}
@code{Cudd_ReadReorderingTime}
@end defun
@defun get_reordering_nb @t{: t -> int}
@code{Cudd_ReadReorderings}
@end defun
@defun get_bddvar_nb @t{: t -> int}
@code{Cudd_ReadSize}
@end defun
@defun get_zddvar_nb @t{: t -> int}
@code{Cudd_ReadZddSize}
@end defun
@defun get_slots @t{: t -> int}
@code{Cudd_ReadSlots}
@end defun
@defun get_used_slots @t{: t -> double}
@code{Cudd_ReadUsedSlots}
@end defun
@defun get_swap_nb @t{: t -> double}
@code{Cudd_ReadSwapSteps}
@end defun

@defun print_info @t{: t -> unit}
@code{Cudd_PrintInfo}@*
Prints the information on the C standard output. It may mix badly with
the @sc{OCaml} output.
@end defun


@c *******************************************************************
@node Bdd, Rdd, Manager, Top
@chapter Bdd
@c *******************************************************************

@menu
* Bdd types::                   
* Bdd extractors::              
* Bdd supports::                
* Operations on supports::      
* Bdd constants and variables::  
* Bdd logical tests::           
* Bdd structural information::  
* Bdd logical operations::      
* Bdd iterators::               
* Bdd quantifiers::             
* Bdd minimizations::           
* Bdd approximations::          
* Bdd miscellaneous::           
* Bdd printing::                
@end menu

@c ===================================================================
@node Bdd types, Bdd extractors, Bdd, Bdd
@section Bdd types
@c ===================================================================

@deftp Datatype t
Abstract type for @sc{Bdd}s. Objects of this type contains both the
top node of the @sc{Bdd} and the manager to which belongs this
node. The manager can be retrieved with @code{manager}. Objects of
these types are automatically garbage collected.
@end deftp
@defvar dummy @t{: t}
``Dummy'' object of type @code{t}.
@end defvar
@deftp Datatype bdd
User datatype for @sc{Bdd}s, obtained from type @code{t} with
@code{inspect}.
@display 
type bdd = 
| Bool of bool
| Ite of int * t * t
@end display
@end deftp

@c ===================================================================
@node Bdd extractors, Bdd supports, Bdd types, Bdd
@section Bdd extractors 
@c ===================================================================

@defun manager @t{: t -> Manager.t}
Returns the manager to which belongs the @sc{Bdd}.
@end defun
@defun is_cst @t{: t -> bool}
@code{Cudd_IsConstant}@*
Is the @sc{Bdd} constant ?
@end defun
@defun is_complement @t{: t -> bool}
@code{Cudd_IsComplement}@*
Is the @sc{Bdd} complemented ? (for experts only)
@end defun
@defun topvar @t{: t -> int}
Returns the top variable of the @sc{Bdd}.
@end defun
@defun dthen @t{: t -> t}
Returns the positive subnode of the @sc{Bdd}.
@end defun
@defun delse @t{: t -> t}
Returns the negative subnode of the @sc{Bdd}.
@end defun
@defun cofactor @t{: bdd:t -> cube:t -> t}
@code{Cudd_Cofactor}@*
Returns the evaluation of @code{bdd} on the cube @code{cube}.
@end defun
@defun cofactors @t{: var:int -> bdd:t -> t * t}
Returns the positive and negative cofactors of @code{bdd} wrt the
variable @code{var}.
@end defun
@defun inspect @t{: t -> bdd}
Decomposes the top node of the @sc{Bdd}.
@end defun

@c ===================================================================
@node Bdd supports, Operations on supports, Bdd extractors, Bdd
@section Bdd supports
@c ===================================================================

@defun support @t{: t -> t}
@code{Cudd_Support}@*
Returns the support of the @sc{Bdd}.
@end defun
@defun supportsize @t{: t -> int}
@code{Cudd_SupportSize}@*
Returns the number of variables the @sc{Bdd} depends on. 
@end defun
@defun vectorsupport @t{: t array -> t}
@code{Cudd_VectorSupport}@* 
Returns the support of the array of @sc{Bdd}s. Raise a @code{Failure}
exception in case where the array is of size 0 (in such case, the
manager is unknown, and we cannot return an empty support).
@end defun
@defun is_var_in @t{: var:int -> t -> bool}
@code{Cuddaux_IsVarIn}@* 
Does the given variable belong the
support of the @sc{Bdd} ?
@end defun

@c ===================================================================
@node Operations on supports, Bdd constants and variables, Bdd supports, Bdd
@section Operations on supports
@c ===================================================================

@defun support_inter @t{: t -> t -> t}
@code{Cudd_bddLiteralSetIntersection}@*
Intersection of supports.
@end defun
@defun support_union @t{: t -> t -> t}
@code{Cudd_bddAnd}@*
Union of supports.
@end defun
@defun support_diff @t{: t -> t -> t}
@code{Cudd_Cofactor}@*
Difference of supports.
@end defun
@defun list_of_support @t{: t -> int list}
Converts a support into a list of variables.
@end defun

@c ===================================================================
@node Bdd constants and variables, Bdd logical tests, Operations on supports, Bdd
@section Bdd constants and variables
@c ===================================================================

@defun dtrue @t{: Manager.t -> t}
@code{Cudd_ReadOne}@*
Returns the true @t{Bdd}.
@end defun
@defun dfalse @t{: Manager.t -> t}
@code{Cudd_ReadLogicZero}@*
Returns the false @t{Bdd}.
@end defun
@defun ithvar @t{: Manager.t -> index:int -> t}
@code{Cudd_bddIthVar}@*
Returns the variable of the given index.
@end defun
@defun newvar @t{: Manager.t -> t}
@code{Cudd_bddNewVar}@*
Returns the next unused variable.
@end defun
@defun newvar_at_level @t{: Manager.t -> level:int -> t}
@code{Cudd_bddNewVarAtLevel}@*
Returns the next unused variable and sets its level.
@end defun


@c ===================================================================
@node Bdd logical tests, Bdd structural information, Bdd constants and variables, Bdd
@section Bdd logical tests
@c ===================================================================

@defun is_true @t{: t -> bool}
Is it a true @sc{Bdd} ?
@end defun
@defun is_false @t{: t -> bool}
Is it a false @sc{Bdd} ?
@end defun
@defun is_equal @t{: t -> t -> bool}
Are the @sc{Bdd}s equal ?
@end defun
@defun is_leq @t{: t -> t -> bool}
@defunx is_included_in @t{: t -> t -> bool}
@code{Cudd_bddLeq}@*
Does the first @sc{Bdd} imply the second one ?
@end defun
@defun is_inter_empty @t{: t -> bool}
Variation of @code{Cudd_bddLeq}@*
Does the two @sc{Bdd}s have a non-empty intersection (conjunction) ?
@end defun
@defun is_equal_when @t{: t -> t -> care:t -> bool}
Variation of @code{Cudd_EquivDC}@*
Are the two first @sc{Bdd}s equal when @code{care} is true ?
@end defun
@defun is_leq_when @t{: t  -> t -> care:t -> bool}
Variation of @code{Cudd_bddLeqUnless}@* 
Does the first @sc{Bdd} imply the second one when @code{care} is true ?
@end defun
@defun is_ite_cst @t{: f:t -> g:t -> h:t -> bool option}
@code{Cudd_bddIteConstant}@* 
If @code{ite f g h} is a not a constant, returns
@code{None}. Otherwise, returns the value of the constant (@code{true}
for the true @sc{Bdd}, @code{false} for the false @sc{Bdd}).
@end defun
@defun is_var_dependent @t{: var:int -> t -> bool}
@code{Cudd_bddIsVarDependent}@*
Is the given variable dependent on others in the @sc{Bdd} ?
@end defun
@defun is_var_essential @t{: var:int -> phase:bool -> t -> bool}
Variation of @code{Cudd_FindEssential}@* 
Is the given variable with the specified phase implied by the @sc{Bdd} ?
@end defun

@c ===================================================================
@node Bdd structural information, Bdd logical operations, Bdd logical tests, Bdd
@section Bdd structural information
@c ===================================================================

@defun size @t{: t -> int}
@code{Cudd_DagSize}  @*
Returns the size if the @sc{Bdd} as a graph (the number of nodes).
@end defun

@defun nbpaths @t{: t -> double}
@code{Cudd_CountPath} @*
Returns the number of paths in the @sc{Bdd} from the root to the leaf.
@end defun

@defun nbminterms @t{: nvars:int -> t -> double}
@code{Cudd_CountMinterm} @* Returns the number of minterms of the
@sc{Bdd} knowing that it depends on @code{nvars} variables.
@end defun

@defun density @t{: nvars:int -> t -> double}
@code{Cudd_Density} @* Returns the density of the @sc{Bdd}, which is the
ratio of the number of minterms to the number of nodes. The @sc{Bdd} is
assumed to depend on @code{nvars} variables.
@end defun

@c ===================================================================
@node Bdd logical operations, Bdd iterators, Bdd structural information, Bdd
@section Bdd logical operations
@c ===================================================================

@defun dnot @t{: t -> t}
@code{Cudd_Not}@*
Negation.
@end defun
@defun dand @t{: t -> t -> t}
@code{Cudd_bddAnd}@*
Intersection.
@end defun
@defun dor @t{: t -> t -> t}
@code{Cudd_bddOr}@*
Union.
@end defun
@defun xor @t{: t -> t -> t}
@code{Cudd_bddXor}@*
Exclusive union.
@end defun
@defun nand @t{: t -> t -> t}
@code{Cudd_bddNand}
@end defun
@defun nor @t{: t -> t -> t}
@code{Cudd_bddNor}
@end defun
@defun nxor @t{: t -> t -> t}
@defunx eq @t{: t -> t -> t}
@code{Cudd_bddXnor}@*
Equality.
@end defun

@defun ite @t{: t -> t -> t -> t}
@code{Cudd_bddIte}@*
If-then-else operation.
@end defun
@defun compose @t{: var:int -> f:t -> bdd:t -> t}
Variation of @code{Cudd_bddCompose}@* 
Substitutes the variable @code{var} with the function @code{f} in
@code{bdd}.
@end defun
@defun vectorcompose @t{: table:(t array) -> t -> t}
@code{Cudd_bddVectorCompose}@* 
Parallel substitution of every variable @code{var} present in the
manager by @code{table.(var)} in @code{bdd}. The size of @code{table}
should be at least @code{Manager.get_bddvar_nb}.
@end defun
@defun intersect @t{: t -> t -> t}
@code{Cudd_bddIntersect}@*
Returns a @sc{Bdd} included in the intersection of the arguments.
@end defun

@defun varmap @t{: t -> t}
@code{Cudd_bddVarMap}@*
Permutes the variables as it has been specified with @code{Manager.set_varmap}.
@end defun
@defun permute @t{: t -> permut:(int array) -> t}
@code{Cudd_bddPermute}@* 
Permutes the variables as it is specified by
@code{permut} (same format as in @code{Manager.set_varmap}).
@end defun

@c ===================================================================
@node Bdd iterators, Bdd quantifiers, Bdd logical operations, Bdd
@section Bdd iterators
@c ===================================================================

@defun iter_node @t{: f:(t -> unit) -> t -> unit}
Variation of @code{Cudd_ForEachNode}@*
Apply the function @code{f} to each (regularized) node of the
@sc{Bdd}.
@end defun
@defun iter_cube @t{: f:(Manager.tbool array -> unit) -> t -> unit}
Variation of @code{Cudd_ForEachCube}@* Apply the function @code{f} to
each cube of the @sc{Bdd}. The cubes are specified as arrays of
elements of type @code{Manager.tbool}. The size of the arrays is equal
to @code{Manager.get_bddvar_nb}, the number of variables present in
the manager.
@end defun

@c ===================================================================
@node Bdd quantifiers, Bdd minimizations, Bdd iterators, Bdd
@section Bdd quantifiers
@c ===================================================================

@defun exist @t{: supp:t -> t -> t}
Variation of @code{Cudd_bddExistAbstract}@*
Quantifies existentially the set of variables defined by @code{supp} in the @sc{Bdd}.
@end defun
@defun forall @t{: supp:t -> t -> t}
Variation of @code{Cudd_bddUnivAbstract}@* Quantifies universally the
set of variables defined by @code{supp} in the @sc{Bdd}.
@end defun
@defun existand @t{: supp:t -> x:t -> y:t -> t}
Variation of @code{Cudd_bddAndAbstract}@* 
Performs simultaneous existential quantification and intersection of
@sc{Bdd}s. Logically equal to @code{exist supp (dand x y)}.
@end defun
@defun existxor @t{: supp:t -> t -> t -> t}
Variation of @code{Cudd_bddXorExistAbstract}@* Performs simultaneous existential
quantification and exclusive or of @sc{Bdd}s.
@end defun
@defun booleandiff @t{: t -> var:int -> t}
@code{Cudd_bddBooleanDiff}@*
Computes the boolean difference of the @sc{Bdd} with
respect to x.
@end defun

@defun cube_of_bdd @t{: t -> t}
@code{Cudd_FindEssential}@* 
Returns the smallest cube (in the sens of inclusion) included in the
@sc{Bdd}.
@end defun
@defun list_of_cube @t{: t -> (int * bool) list}
Converts a cube into a list of pairs of a variable and a phase.
@end defun
@defun cube_union @t{: t -> t -> t}
@code{Cuddaux_bddCubeUnion}@* Computes the "union" of cubes, wich is the
smallest cube containing both the argument cubes.
@end defun

@c ===================================================================
@node Bdd minimizations, Bdd approximations, Bdd quantifiers, Bdd
@section Bdd minimizations
@c ===================================================================

@defun constrain @t{: t -> t -> t}
@defunx restrict @t{: t -> t -> t}
@code{Cudd_bddConstrain} @code{Cuddaux_bddRestrict} @* Constrain and
Restrict generelized cofactors operators as defined by Madre and
Coudert. @code{gencof f c} (where @code{gencof} is any generalized
cofator operator) returns a (smaller) @sc{Bdd} that coincides with
@code{f} whenever @code{c} is true.
@end defun
@defun tdconstrain @t{: t -> t -> t}
@defunx tdrestrict @t{: t -> t -> t}
@code{Cuddaux_bddTDConstrain} @code{Cuddaux_bddTDRestrict} @*
Constrain and Restrict operators as defined by P. Raymond in his PhD. thesis. Based on a kind of unification. More efficient but more expensive.
@end defun

@defun minimize @t{: t -> t -> t}
@defunx licompaction @t{: t -> t -> t}
@code{Cudd_bddMinimize} @code{Cudd_bddLICompaction} @*
Others generalized cofactor operators.
@end defun

@defun squeeze @t{: t -> t -> t}
@code{Cudd_bddSqueeze} @* @code{sqeeze lower upper} returns a (smaller)
@sc{Bdd} which is in the functional interval @code{[lower,upper]}.
@end defun

@c ===================================================================
@node Bdd approximations, Bdd miscellaneous, Bdd minimizations, Bdd
@section Bdd approximations
@c ===================================================================

@defun clippingand @t{: f:t -> g:t -> maxdepth:int -> direction:bool -> t}
@defunx clippingexistand @t{: cube:t -> f:t -> g:t -> maxdepth:int -> direction:bool -> t}
@code{Cudd_bddClippingAnd} @code{Cudd_bddClippingAndAbstract}(order of @sc{Bdd} arguments changed)
@end defun

@defun underapprox @t{: nvars:int -> threshold:int -> safe:int -> quality:float -> t -> t}
@defunx overapprox @t{: nvars:int -> threshold:int -> safe:int -> quality:float -> t -> t}
@code{Cudd_UnderApprox} @code{Cudd_OverApprox}
@end defun

@defun remapunderapprox @t{: nvars:int -> threshold:int -> quality:float -> t -> t}
@defunx remapoverapprox @t{: nvars:int -> threshold:int -> quality:float -> t -> t}
@code{Cudd_RemapUnderApprox} @code{Cudd_RemapOverApprox}
@end defun

@defun biasedunderapprox @t{: nvars:int -> threshold:int -> quality1:float -> quality2:float -> t -> t}
@defunx biasedoverapprox @t{: nvars:int -> threshold:int -> quality1:float -> quality2:float -> t -> t}
@code{Cudd_BiasedUnderApprox} @code{Cudd_BiasedOverApprox}
@end defun

@defun subsetcompress @t{: nvars:int -> threshold:int -> t -> t}
@defunx supersetcompress @t{: nvars:int -> threshold:int -> t -> t}
@defunx subsetHB @t{: nvars:int -> threshold:int -> t -> t}
@defunx supersetHB @t{: nvars:int -> threshold:int -> t -> t}
@defunx subsetSP @t{: nvars:int -> threshold:int -> hardlimit:bool -> t -> t}
@defunx supersetSP @t{: nvars:int -> threshold:int -> hardlimit:bool -> t -> t}
@code{Cudd_SubsetCompress} @code{Cudd_SupersetCompress} @*
@code{Cudd_SubsetHeavyBranch} @code{Cudd_SupersetHeavyBranch} @*
@code{Cudd_SubsetShortPaths} @code{Cudd_SupersetShortPaths} @*
Finds a dense subset (superset) of a @sc{Bdd}.
@end defun

@defun approxconjdecomp @t{: t -> (t*t) option}
@defunx approxdisjdecomp @t{: t -> (t*t) option}
@defunx iterconjdecomp @t{: t -> (t*t) option}
@defunx iterdisjdecomp @t{: t -> (t*t) option}
@defunx genconjdecomp @t{: t -> (t*t) option}
@defunx gendisjdecomp @t{: t -> (t*t) option}
@defunx varconjdecomp @t{: t -> (t*t) option}
@defunx vardisjdecomp @t{: t -> (t*t) option}
@code{Cudd_bddApproxConjDecomp} @code{Cudd_bddApproxDisjDecomp} @*
@code{Cudd_bddIterConjDecomp} @code{Cudd_bddIterDisjDecomp} @*
@code{Cudd_bddGenConjDecomp} @code{Cudd_bddGenDisjDecomp} @*
@code{Cudd_bddVarConjDecomp} @code{Cudd_bddVarDisjDecomp} @*
Performs
two-way conjunctive (disjunctive) decomposition of a @sc{Bdd}. Returns a
pair if successfull, @code{None} if no decomposition has been found.
@end defun

@c ===================================================================
@node Bdd miscellaneous, Bdd printing, Bdd approximations, Bdd
@section Bdd miscellaneous
@c ===================================================================

@defun transfer @t{: t -> Manager.t -> t}
@code{Cudd_bddTransfer} @*
Transfers a @sc{Bdd} from its manager to the given manager.
@end defun

@defun correlation @t{: f:t -> g:t -> float}
@code{Cudd_bddCorrelation} @* Computes the correlation of f and g (if
@code{f=g}, their correlation is 1, if @code{f=not g}, it is 0).
@end defun
@defun correlationweights @t{: f:t -> g:t -> prob:float array -> float}
@code{Cudd_bddCorrelationWeigths} @* @code{prob.(i)} is supposed to
contain the probability of the i-th input variable to
 be 1. Returns the probability for @code{f} and @code{g} to have the
same value.
@end defun

@c ===================================================================
@node Bdd printing,  , Bdd miscellaneous, Bdd
@section Bdd printing
@c ===================================================================

@defun _print @t{: t -> unit}
@code{Cudd_Printminterm} @*
C printing function. The output may mix badly with the @sc{OCaml} output.
@end defun

@defun print__minterm @t{: Format.formatter -> t -> unit}
Prints the minterms of the @sc{Bdd} in the same way as @code{Cudd_Printminterm}.
@end defun
@defun print_minterm @t{: bassoc:(int -> string) -> Format.formatter -> t -> unit}
Prints the minterms of the @sc{Bdd} using @code{bassoc} to convert
indices of variables to names.
@end defun
@defun print @t{: bassoc:(int -> string) -> Format.formatter -> t -> unit}
Prints the @sc{Bdd} by recursively decomposing it as monomial followed by a tree.
@end defun

@c *******************************************************************
@node Rdd, Idd, Bdd, Top
@chapter Rdd
@c *******************************************************************

@c ===================================================================
@menu
* Rdd types::                   
* Rdd extractors::              
* Rdd supports::                
* Rdd classical operations::    
* Rdd variable mapping::        
* Rdd logical tests::           
* Rdd structural information::  
* Rdd iterators::               
* Rdd leaves and guards::       
* Rdd minimizations::           
* Rdd conversions::             
* Rdd quantifications::         
* Rdd algebraic operations::    
* Rdd matrix operations::       
* Rdd user operations::         
* Rdd miscellaneous::           
* Rdd printing::                
@end menu

@node Rdd types, Rdd extractors, Rdd, Rdd
@section Rdd types
@c ===================================================================

@deftp Datatype t
Abstract type for @sc{Rdd}s (which corresponds to @sc{Cudd}
@sc{Adds}). Objects of this type contains both the top node of the
@sc{Rdd} and the manager to which belongs this node. The manager can be
retrieved with @code{manager}. Objects of these types are automatically
garbage collected.
@end deftp
@defvar dummy @t{: t}
``Dummy'' object of type @code{t}.
@end defvar
@deftp Datatype rdd
User datatype for @sc{Rdd}s, obtained from type @code{t} with
@code{inspect}.
@display 
type rdd = 
| Leaf of float
| Ite of int * t * t
@end display
@end deftp

@deftp Datatype id_unop
@deftpx Datatype id_binop
@deftpx Datatype id_combinop
Abstract types for user defined operations. See below.
@end deftp

@c ===================================================================
@node Rdd extractors, Rdd supports, Rdd types, Rdd
@section Rdd extractors 
@c ===================================================================

@defun manager @t{: t -> Manager.t}
Returns the manager to which belongs the @sc{Rdd}.
@end defun
@defun is_cst @t{: t -> bool}
@code{Cudd_IsConstant}@*
Is the @sc{Rdd} constant ?
@end defun
@defun topvar @t{: t -> int}
Returns the top variable of the @sc{Rdd}.
@end defun
@defun dthen @t{: t -> t}
Returns the positive subnode of the @sc{Rdd}.
@end defun
@defun delse @t{: t -> t}
Returns the negative subnode of the @sc{Rdd}.
@end defun
@defun cofactor @t{: bdd:t -> cube:t -> t}
@code{Cudd_Cofactor}@*
Returns the evaluation of @code{bdd} on the cube @code{cube}.
@end defun
@defun cofactors @t{: var:int -> bdd:t -> t * t}
Returns the positive and negative cofactors of @code{bdd} wrt the
variable @code{var}.
@end defun
@defun inspect @t{: t -> bdd}
Decomposes the top node of the @sc{Rdd}.
@end defun

@c ===================================================================
@node Rdd supports, Rdd classical operations, Rdd extractors, Rdd
@section Rdd supports
@c ===================================================================

@defun support @t{: t -> Bdd.t}
@code{Cudd_Support}@*
Returns the support of the @sc{Rdd}.
@end defun
@defun supportsize @t{: t -> int}
@code{Cudd_SupportSize}@*
Returns the number of variables the @sc{Rdd} depends on. 
@end defun
@defun vectorsupport @t{: t array -> Bdd.t}
@code{Cudd_VectorSupport}@* 
Returns the support of the array of @sc{Rdd}s. Raise a @code{Failure}
exception in case where the array is of size 0 (in such case, the
manager is unknown, and we cannot return an empty support).
@end defun
@defun vectorsupport2 @t{: Bdd.t -> t array -> Bdd.t}
@code{Cudd_VectorSupport}@* Returns the support of the array of
@sc{Bdd}s and @sc{Rdd}s. Raise a @code{Failure} exception in case where
both arrays are of size 0 (in such case, the manager is unknown, and we
cannot return an empty support).
@end defun
@defun is_var_in @t{: var:int -> t -> bool}
@code{Cuddaux_IsVarIn}@* 
Does the given variable belong the
support of the @sc{Rdd} ?
@end defun



@c ===================================================================
@node Rdd classical operations, Rdd variable mapping, Rdd supports, Rdd
@section Rdd classical operations
@c ===================================================================

@defun cst @t{: Manager.t -> float -> t}
@code{Cudd_addConst}@*
Returns a constant @sc{Rdd} holding the given value.
@end defun
@defun ite @t{: Bdd.t -> t -> t -> t}
If-then-else operation, with the condition being a @sc{Bdd}.
@end defun
@defun compose @t{: var:int -> f:Bdd.t -> rdd:t -> t}
@code{Cuddaux_addCompose}
Substitutes the variable @code{var} with the function @code{f} in
@code{rdd}.
@end defun
@defun vectorcompose @t{: table:(Bdd.t array) -> rdd:t -> t}
@code{Cuddaux_addVectorCompose}@* 
Parallel substitution of every variable @code{var} present in the
manager by @code{table.(var)} in @code{rdd}. The size of @code{table}
should be at least @code{Manager.get_bddvar_nb}.
@end defun

@c ===================================================================
@node Rdd variable mapping, Rdd logical tests, Rdd classical operations, Rdd
@section Rdd vraible mapping
@c ===================================================================

@defun varmap @t{: t -> t}
@code{Cuddaux_addVarMap}@*
Permutes the variables as it has been specified with @code{Manager.set_varmap}.
@end defun
@defun permute @t{: t -> (permut:int array) -> t}
@code{Cudd_addPermute}@* 
Permutes the variables as it is specified by
@code{permut} (same format as in @code{Manager.set_varmap}).
@end defun

@c ===================================================================
@node Rdd logical tests, Rdd structural information, Rdd variable mapping, Rdd
@section Rdd logical tests
@c ===================================================================

@defun is_equal @t{: t -> t -> bool}
Are the @sc{Rdd}s equal ?
@end defun
@defun is_equal_when @t{: t -> t -> care:Bdd.t -> bool}
Variation of @code{Cudd_EquivDC}@*
Are the two first @sc{Rdd}s equal when @code{care} is true ?
@end defun
@defun is_eval_cst @t{: t -> Bdd.t -> float option}
@code{Cuddaux_addEvalConst}@* Is the @sc{Rdd} constant whenever the
@sc{Bdd} is true ? If not, returns @code{None}, otherwise returns the
corresponding value.
@end defun
@defun is_ite_cst @t{: f:Bdd.t -> g:t -> h:t -> float option}
@code{Cuddaux_addIteConstant}@* 
If @code{ite f g h} is a not a constant, returns
@code{None}. Otherwise, returns the value of the corresponding value.
@end defun


@c ===================================================================
@node Rdd structural information, Rdd iterators, Rdd logical tests, Rdd
@section Rdd structural information
@c ===================================================================

@defun size @t{: t -> int}
@code{Cudd_DagSize}  @*
Returns the size if the @sc{Rdd} as a graph (the number of nodes).
@end defun

@defun nbpaths @t{: t -> double}
@code{Cudd_CountPath} @*
Returns the number of paths in the @sc{Rdd} from the root to the leaves.
@end defun
@defun nbnonzeropaths @t{: t -> double}
@code{Cudd_CountPathsToNonZero} @*
Returns the number of paths in the @sc{Rdd} from the root to non-zero leaves.
@end defun

@defun nbminterms @t{: nvars:int -> t -> double}
@code{Cudd_CountMinterm} @* Returns the number of minterms of the
@sc{Rdd} leading to a non-zero and a non-background value, knowing that
it depends on @code{nvars} variables.
@end defun

@defun density @t{: nvars:int -> t -> double}
@code{Cudd_Density} @* Returns the density of the @sc{Rdd}, which is the
ratio of the number of minterms to the number of nodes. The @sc{Rdd} is
assumed to depend on @code{nvars} variables.
@end defun

@defun nbleaves @t{: t -> int}
@code{Cudd_CountLeaves} @*
Returns the number of leaves of the @sc{Rdd}.
@end defun

@c ===================================================================
@node Rdd iterators, Rdd leaves and guards, Rdd structural information, Rdd
@section Rdd iterators
@c ===================================================================

@defun iter_node @t{: f:(t -> unit) -> t -> unit}
Variation of @code{Cudd_ForEachNode}@*
Apply the function @code{f} to each node of the
@sc{Rdd}.
@end defun
@defun iter_cube @t{: f:(Manager.tbool array -> float -> unit) -> t -> unit}
Variation of @code{Cudd_ForEachCube}@* Apply the function @code{f} to
each cube of the @sc{Rdd}. The cubes are specified as arrays of elements
of type @code{Manager.tbool}, followed by the leaf value. The size of the
arrays is equal to @code{Manager.get_bddvar_nb}, the number of variables
present in the manager.
@end defun

@c ===================================================================
@node Rdd leaves and guards, Rdd minimizations, Rdd iterators, Rdd
@section Rdd leaves and guards
@c ===================================================================

@defun guard_of_node @t{: f:t -> node:t -> Bdd.t}
@code{Cuddaux_addGuardOfNode} @* @code{node} is supposed to be a node of
@code{f}. Returns a @sc{Bdd} equal to the sum of the paths that leads
from the root node @var{f} to the node @var{node} in @var{f}.
@end defun
@defun guard_of_leaf @t{: f:t -> val:float -> Bdd.t}
@code{Cuddaux_addGuardOfNode} @*
Previous function with @code{node= (cst val)}.
@end defun
@defun nodes_below_level @t{: f:t -> level:(int option) -> t array}
@code{Cuddaux_NodesBelowLevel} @* The functions collects in the result
all the nodes pointed by @code{f}, indexed by a variable of level
greater or equal than @code{level}, and encountered first in the
top-down exploration (i.e., whenever a node is collected, its sons are
not collected). If @code{level=None}, then only constant nodes are
collected.
@end defun

@defun leaves @t{: t -> float array}
Returns the set of leaf values of the @sc{Rdd}.
@end defun
@defun guardleafs @t{: t -> (Bdd.t * float) array}
Returns the set of leaf values together with their guard in the @sc{Rdd}.
@end defun

@c ===================================================================
@node Rdd minimizations, Rdd conversions, Rdd leaves and guards, Rdd
@section Rdd minimizations
@c ===================================================================

@defun constrain @t{: t -> Bdd.t -> t}
@defunx restrict @t{: t -> Bdd.t -> t}
@code{Cuddaux_addConstrain} @code{Cuddaux_addRestrict} @* Constrain and
Restrict generelized cofactors operators as defined by Madre and
Coudert. @code{gencof f c} (where @code{gencof} is any generalized
cofator operator) returns a (smaller) @sc{Rdd} that coincides with
@code{f} whenever @code{c} is true.
@end defun
@defun tdconstrain @t{: t -> t -> t}
@defunx tdrestrict @t{: t -> t -> t}
@code{Cuddaux_addTDConstrain} @code{Cuddaux_addTDRestrict} @* Constrain
and Restrict operators as defined by P. Raymond in his
PhD. thesis. Based on a kind of unification. More efficient but more
expensive.
@end defun

@c ===================================================================
@node Rdd conversions, Rdd quantifications, Rdd minimizations, Rdd
@section Rdd conversions
@c ===================================================================

@defun of_bdd @t{: Bdd.t -> t}
@code{Cudd_BddToAdd}@*
Creates a 0-1 @sc{Rdd} from a @sc{Bdd}.
@end defun
@defun to_bdd @t{: t -> Bdd.t}
@code{Cudd_addBddPattern}@* Converts a @sc{Rdd} to a @sc{Bdd} by
replacing all leaf values different from 0 with true.
@end defun
@defun to_bdd_threshold @t{: threshold:float -> t -> Bdd.t}
@code{Cudd_addBddThreshold}@* Converts a @sc{Rdd} to a @sc{Bdd} by
replacing all leaf values greater than or equal to @code{threshold} with
true.
@end defun
@defun to_bdd_strictthreshold @t{: threshold:float -> t -> Bdd.t}
@code{Cudd_addBddStrictThreshold}@* Converts a @sc{Rdd} to a @sc{Bdd} by
replacing all leaf values strictly greater than @code{threshold} with
true.
@end defun
@defun to_bdd_interval @t{: lower:float -> upper:float -> t -> Bdd.t}
@code{Cudd_addBddInterval}@* Converts a @sc{Rdd} to a @sc{Bdd} by
replacing all leaf values greater than or equal to @code{lower} and less
than or equal to @code{upper} with true.
@end defun

@c ===================================================================
@node Rdd quantifications, Rdd algebraic operations, Rdd conversions, Rdd
@section Rdd quantifications
@c ===================================================================

@defun exist @t{: cube:Bdd.t -> t -> t}
Variation of @code{Cudd_addExistAbstract} @* Abstracts all the variables
in @code{cube} from the @sc{Rdd} by summing over all possible
  values taken by the variables.
@end defun
@defun forall @t{: cube:Bdd.t -> t -> t}
Variation of @code{Cudd_addUnivAbstract} @* Abstracts all the variables
in @code{cube} from the @sc{Rdd} by taking the product over all possible
  values taken by the variables.
@end defun

@c ===================================================================
@node Rdd algebraic operations, Rdd matrix operations, Rdd quantifications, Rdd
@section Rdd algebraic operations
@c ===================================================================

@defun is_leq @t{: f:t -> g:t -> bool}
@code{Cudd_addLeq} @*
Is @code{f} less than or equal to @code{g} with the pointwise functional
ordering ?
@end defun

@defun add @t{: t -> t -> t}
@defunx sub @t{: t -> t -> t}
@defunx mul @t{: t -> t -> t}
@defunx div @t{: t -> t -> t}
@defunx min @t{: t -> t -> t}
@defunx max @t{: t -> t -> t}
@defunx agreement @t{: t -> t -> t}
@defunx diff @t{: t -> t -> t}
@defunx threshold @t{: t -> t -> t}
@defunx setNZ @t{: t -> t -> t}
@code{Cudd_addApply} used with resp. @code{Cudd_addPlus, Cudd_addMinus,
Cudd_addTimes, Cudd_addDivide, Cudd_addMinimum, Cudd_addMaximum,
Cudd_addAgreement, Cudd_addDiff, Cudd_addThreshold, Cudd_addSetNZ}
@end defun

@defun log @t{: t -> t}
@code{Cudd_addMonadicApply} used with @code{Cudd_addLog}
@end defun


@c ===================================================================
@node Rdd matrix operations, Rdd user operations, Rdd algebraic operations, Rdd
@section Rdd matrix operations
@c ===================================================================

@defun matrix_multiply @t{: z:(int array) -> A:t -> B:t -> t}
Variation of @code{Cudd_addMatrixMultiply} @* 
Performs matrix multiplication of @code{A} and @code{B}, with @code{z}
being the summation variables, which means that they are used to refer
columns of @code{A} and to rows of @code{B}.
@end defun
@defun times_plus @t{: z:(int array) -> A:t -> B:t -> t}
@defunx triangle @t{: z:(int array) -> A:t -> B:t -> t}
Variation of @code{Cudd_addTimesPlus} and @code{Cudd_addTriangle}
@end defun

@c ===================================================================
@node Rdd user operations, Rdd miscellaneous, Rdd matrix operations, Rdd
@section Rdd user operations
@c ===================================================================

These functions allow to define operations on @sc{Rdd}s from operations
defined on reals. The number of user operations is limited. The limit
can be modified at compilation time.

@defun alloc_unop @t{: (float -> float) -> id_unop}
@defunx alloc_binop @t{: (float -> float -> float) -> id_binop}
@defunx alloc_combinop @t{: (float -> float -> float) -> id_combinop}
Registers operations on leaves and returns their identification number
(which is an abstract datatype). Possible types of operations are unary
operations, binary operations and commutative binary operations.
@end defun

@defun apply_unop @t{: id_unop -> t -> t}
@defunx apply_binop @t{: id_binop -> t -> t -> t}
@defunx apply_combinop @t{: id_combinop -> t -> t -> t}
Applies the given operations (initially defined on leaf values) to
@sc{Rdd}s, by using @code{Cudd_addMonadicApply} or @code{Cudd_addApply}.
@end defun

@c ===================================================================
@node Rdd miscellaneous, Rdd printing, Rdd user operations, Rdd
@section Rdd miscellaneous
@c ===================================================================

@defun transfer @t{: t -> Manager.t -> t}
@code{Cuddaux_addTransfer} @* Transfers a @sc{Rdd} from its manager to the
given manager.
@end defun

@c ===================================================================
@node Rdd printing,  , Rdd miscellaneous, Rdd
@section Rdd printing
@c ===================================================================

@defun _print @t{: t -> unit}
@code{Cudd_Printminterm} @*
C printing function. The output may mix badly with the @sc{OCaml} output.
@end defun

@defun print__minterm @t{: Format.formatter -> t -> unit}
Prints the minterms of the @sc{Rdd} in the same way as @code{Cudd_Printminterm}.
@end defun
@defun print_minterm @t{: bassoc:(int -> string) -> lassoc:(float -> string) -> Format.formatter -> t -> unit}
Prints the minterms of the @sc{Rdd} using @code{bassoc} to convert
indices of variables to names and @code{lassoc} to convert leaf values
to strings.
@end defun
@defun print @t{: bassoc:(int -> string) -> lassoc:(float -> string) -> Format.formatter -> t -> unit}
Prints the @sc{Rdd} by recursively decomposing it as monomial followed by a tree.
@end defun


@c *******************************************************************
@node Idd, Mtbdd, Rdd, Top
@chapter Idd
@c *******************************************************************

@sc{Idd}s are @sc{Rdd}s with integer leaf values, instead of floating
point numbers. Most of the functions available for @sc{Rdd}s have their
equivalent for @sc{Idd}s, except algebraic operations and operations for
which it doesn't make too much sense. See @file{idd.mli} for details.

The main use of this module is to serve as a basis for module
@code{Mtbdd}. We could have used directly @sc{Rdd}, but for efficiency
reason we prefered to use this module (in which conversions are done in
C and does not generate unuseful @sc{OCaml} block allocation).

@c *******************************************************************
@node Mtbdd, Appendices, Idd, Top
@chapter Mtbdd
@c *******************************************************************

@code{Mtbdd}s are decision diagrams in which leaf values are a
user-defined datatype. This datatype is defined by a module, and then
the functor @code{Mtbdd.Make} allows to generate a new module offering
(nearly) all the functions available for @code{Idd}.

The implementation is based on module @code{Idd}, and use correspondance
tables between integers and objects of the user-defined datatype.

@menu
* Mtbdd module types and functors::  
* Mtbdd types::                 
* Mtbdd very internal leaf management::  
* Mtbdd internal leaf management::  
@end menu


@c ===================================================================
@node Mtbdd module types and functors, Mtbdd types, Mtbdd, Mtbdd
@section Mtbdd module types and functors
@c ===================================================================

@deftp {Module type} LeafType
Type of modules defining a user datatype.
@display 
module type LeafType =
  sig
    type t
    val equal: t -> t -> bool
    val hash: t -> int
    val background: t
  end
@end display
@code{t} is the datatype, @code{equal} is the equality predicate on that
type, @code{hash} is a suitable hash function, and @code{background} is
the value associated to the 0 constant @sc{Idd}.
@end deftp

@deftp {Module type} S
Type of modules generated from @code{LeafType}.
@display 
module type LeafType =
  sig
    type leaf
    type t
    type id_unop
    type id_binop
    type id_combinop
    type mtbdd = 
      | Leaf of leaf
      | Ite of int * t * t

    val leafbackground: leaf
	
    (* internal operations, not meant to be used by casual user *)
    module Hash: (Hashtbl.S with type key = leaf)
    val hasht: int Hash.t
    module Assoc: (Map.S with type key = int)
    val assoct: (leaf Assoc.t) ref

    val leaf_of_id: int -> leaf
    val id_of_leaf: leaf -> int
    val remove_leaf: leaf -> unit
    val iter_leaf : (int -> leaf -> unit) -> unit
    external to_idd: t -> Idd.t = "%identity"
    external of_idd: Idd.t -> t = "%identity"

    (* Standard operations *)
    ...
  end
@end display
The remaining operations (refered to by @code{...}) are the equivalent
of @code{Idd} operations, look at @code{mtbdd.mli} and @code{mtbdd.ml}
for details. We detail below the above-written fields.
@end deftp

@deftp Module Make @code{: functor (Leaf: LeafType) -> (S with type leaf = Leaf.t)}
The functor that allows to generate new kind of binary decision diagrams.
@end deftp


@c ===================================================================
@node Mtbdd types, Mtbdd very internal leaf management, Mtbdd module types and functors, Mtbdd
@section Mtbdd types
@c ===================================================================

We describe the meaning of types in the module type @code{S}.

@deftp Datatype leaf
The type of leaf values
@end deftp
@deftp Datatype t
The abstract type of binary decision diagram, the leaf values of which are
objects of type @code{leaf}.
@end deftp
@deftp Datatype id_unop
@deftpx Datatype id_binop
@deftpx Datatype id_combinop
Abstract types for user defined operations.
@end deftp
@deftp Datatype mtbdd
@display 
type mtbdd = 
  | Leaf of leaf
  | Ite of int * t * t
@end display
User datatype for objects of type @code{t}, obtained with
@code{inspect}.
@end deftp


@c ===================================================================
@node Mtbdd very internal leaf management, Mtbdd internal leaf management, Mtbdd types, Mtbdd
@section Mtbdd very internal leaf management
@c ===================================================================

These objects are not intended to be used by casual users !

@deftp Module Hash @t{: Hashtbl.S with type key = leaf}
@end deftp
@defvar hasht @t{: int Hash.t}
Hashtable that associates integers to leaf values.
@end defvar
@deftp Module Assoc @t{: Map.S with type key = int}
@end deftp
@defvar assoct @t{: (leaf Assoc.t) ref}
Association table that associates leaf values to integers.
@end defvar

@c ===================================================================
@node Mtbdd internal leaf management,  , Mtbdd very internal leaf management, Mtbdd
@section Mtbdd internal leaf management
@c ===================================================================

These functions are still not necessary for a normal use of the module.

@defun leaf_of_id @t{: int -> leaf}
@defunx id_of_leaf @t{: leaf -> int}
Conversions between leaves and their indices.
@end defun
@defun remove_leaf @t{: leaf -> unit}
Remove the given leaf from the internal tables. Be cautious: it may
still exist an object of type @code{t} which refers to this leaf ! In
such case, an exception @code{Not_found} is likely to be raised soon or
later.
@end defun
@defun iter_leaf @t{: int -> leaf -> unit}
Iterates on the set of leaves registered in the module.
@end defun
@defun to_idd @t{: t -> Idd.t}
@defunx of_idd @t{: Idd.t -> t}
Conversions between objects of type @code{t} and @sc{Idd}s. Be cautious,
these two functions disable the normal type checking !
@end defun

@c *******************************************************************
@node Appendices,  , Mtbdd, Top
@appendix Appendices
@c *******************************************************************

@menu
* Datatype Index::              
* Variable Index::              
* Function Index::              
@end menu

@c ===================================================================
@node Datatype Index, Variable Index, Appendices, Appendices
@appendixsec Datatype Index
@printindex tp
@c ===================================================================

@c ===================================================================
@node Variable Index, Function Index, Datatype Index, Appendices
@appendixsec Variable Index
@printindex vr
@c ===================================================================

@c ===================================================================
@node Function Index,  , Variable Index, Appendices
@appendixsec Function Index
@printindex fn
@c ===================================================================

@contents 
@bye
