/* -*- mode: c -*- */

/* This file is part of the MLCUDDIDL Library, released under LGPL license.
   Please read the COPYING file packaged in the distribution  */

quote(C, "
#include \"caml/custom.h\"
#include \"cudd_caml.h\"
")

import "manager.idl";
import "bdd.idl";

/* ********************************************************************** */
/* Management of abstract datatypes */
/* ********************************************************************** */

/* For nodes that need Garbage collection */
typedef [abstract,c2ml(camlidl_cudd_node_c2ml),ml2c(camlidl_cudd_node_ml2c)] struct node__t idd__t;
quote(MLI,"(** BDDs with [int] leaves *)")

quote(MLMLI,"
(** Public type for exploring the abstract type [t] *)\n\
type idd = \n\
| Leaf of int \n\
| Ite of int * t * t \n\
\n\
\n\
type id_unop \n\
type id_binop \n\
type id_combinop \n\
  (** For user-defined operations *)\n\
")

quote(MLI,"(** Dummy value (useful in some cases) *)")
quote(MLI,"val dummy : t")

quote(MLI,"\n 
(** We refer to the module {!Rdd} for the description of the interface, as
it is nearly identical to {!Rdd}, except that float leaves are replaced by
integer leaves. *)
")

/* ********************************************************************** */
/* Extractors */
/* ********************************************************************** */
quote(MLMLI,"")
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Extractors} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external manager : t -> Manager.t = \"camlidl_bdd_manager\"
external is_cst : t -> bool = \"camlidl_bdd_is_cst\"
external topvar : t -> int = \"camlidl_bdd_topvar\"
external dthen : t -> t = \"camlidl_rdd_dthen\"
external delse : t -> t = \"camlidl_rdd_delse\"
external cofactors : int -> t ->  t*t = \"camlidl_rdd_cofactors\"
external cofactor : t -> Bdd.t -> t = \"camlidl_rdd_cofactor\"
")
int dval(idd__t no) quote(call,"
if (!cuddIsConstant(no.node))
  failwith(\"Rdd.dval: non constant RDD\")
;
_res = cuddV(no.node);
");

quote(MLMLI,"external inspect: idd__t -> idd = \"camlidl_idd_inspect\"")

/* ********************************************************************** */
/* Supports */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Supports} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external support : t -> Bdd.t = \"camlidl_bdd_support\"
external supportsize : t -> int = \"camlidl_bdd_supportsize\"
external is_var_in : int -> t -> bool = \"camlidl_bdd_is_var_in\"
external vectorsupport : t array -> Bdd.t = \"camlidl_bdd_vectorsupport\"
external vectorsupport2 : Bdd.t array -> t array -> Bdd.t = \"camlidl_rdd_vectorsupport2\"
")

/* ********************************************************************** */
/* Classical operations */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Classical operations} *)")
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"")

idd__t cst(manager__t man, int val)
  quote(call, "Begin_roots1(_v_man); _res.man = man; _res.node = Cudd_addConst(man->man,(int)val);")
     quote(dealloc,"End_roots();");

quote(MLMLI,"
external ite : Bdd.t -> t -> t -> t = \"camlidl_rdd_ite\"
external ite_cst : Bdd.t -> t -> t -> t option = \"camlidl_cudd_rdd_ite_cst\"
external eval_cst : t -> Bdd.t -> t option = \"camlidl_cudd_rdd_eval_cst\"
external compose : int -> Bdd.t -> t -> t = \"camlidl_rdd_compose\"
external vectorcompose: Bdd.t array -> idd__t -> idd__t = \"camlidl_rdd_vectorcompose\"
")

quote(ML,"
let dummy = cst Manager.dummy (int_of_float (Manager.get_background Manager.dummy))
")

/* ********************************************************************** */
/* Logical tests */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Logical tests} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external is_equal : t -> t -> bool = \"camlidl_bdd_is_equal\"
external is_equal_when: t -> t -> Bdd.t -> bool = \"camlidl_bdd_is_equal_when\"
")

[unique] int * is_eval_cst(idd__t no1, bdd__t no2)
quote(call,
"  {
     static int storage;
     DdNode* node;

     CHECK_MAN2;
     node = Cuddaux_addEvalConst(no1.man->man,no2.node,no1.node);
     if (node==DD_NON_CONSTANT || ! cuddIsConstant(node))
       _res = 0;
     else {
       storage = (int)(cuddV(node));
       _res = &storage;
     }
   }
");

[unique] int * is_ite_cst(bdd__t no1, idd__t no2, idd__t no3)
quote(call,
"  {
     static int storage;

     DdNode* node;
     CHECK_MAN3;
     node = Cuddaux_addIteConstant(no1.man->man,no1.node,no2.node,no3.node);
     if (node==DD_NON_CONSTANT || ! cuddIsConstant(node))
       _res = 0;
     else {
       storage = (int)(cuddV(node));
       _res = &storage;
     }
   }
");

/* ********************************************************************** */
/* Structural information */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Structural information} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external size : t -> int = \"camlidl_bdd_size\"
external nbpaths : t -> float = \"camlidl_bdd_nbpaths\"
external nbnonzeropaths : t -> float = \"camlidl_bdd_nbtruepaths\"
external nbminterms : int -> t -> float = \"camlidl_bdd_nbminterms\"
external density : int -> t -> float = \"camlidl_bdd_density\"
external nbleaves : t -> int = \"camlidl_rdd_nbleaves\"
")

/* ********************************************************************** */
/* Variable Mapping */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Variable mapping} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external varmap : t -> t = \"camlidl_rdd_varmap\"
external permute : t -> int array -> t = \"camlidl_rdd_permute\"
")

/* ********************************************************************** */
/* Iterators */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Iterators} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI, "
external iter_node: (t -> unit) -> t -> unit = \"camlidl_cudd_iter_node\"
external iter_cube: (Manager.tbool array -> int -> unit) -> t -> unit = \"camlidl_idd_iter_cube\"
")

/* ********************************************************************** */
/* Leaves and guards */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Leaves and guards} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external guard_of_node : t -> t -> Bdd.t = \"camlidl_rdd_guard_of_node\"
external guard_of_nonbackground : t -> Bdd.t = \"camlidl_rdd_guard_of_nonbackground\"
external nodes_below_level: t -> int option -> int -> t array = \"camlidl_rdd_nodes_below_level\"
external leaves: t -> int array = \"camlidl_idd_leaves\"
external pick_leaf: t -> int option = \"camlidl_idd_pick_leaf\"
")

bdd__t guard_of_leaf(idd__t no, int val)
     quote(call,"
Begin_roots1(_v_no);
{
DdNode* nval = Cudd_addConst(no.man->man, (double)val);
cuddRef(nval);
_res.man = no.man;
_res.node = Cuddaux_addGuardOfNode(no.man->man,no.node,nval);
cuddRef(_res.node);
Cudd_RecursiveDeref(no.man->man,nval);
cuddDeref(_res.node);
}
End_roots();
");

quote(MLI,"val guardleafs : t -> (Bdd.t * int) array")
quote(ML,"
let guardleafs rdd =
  let tab = leaves rdd in
  Array.map (fun leaf -> (guard_of_leaf rdd leaf,leaf)) tab
")

/* ********************************************************************** */
/* Minimizations */
/* ********************************************************************** */
quote(MLMLI,"")
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Minimizations} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external constrain: t -> Bdd.t -> t = \"camlidl_rdd_constrain\"
external tdconstrain: t -> Bdd.t -> t = \"camlidl_rdd_tdconstrain\"
external restrict: t -> Bdd.t -> t = \"camlidl_rdd_restrict\"
external tdrestrict : t -> Bdd.t -> t = \"camlidl_rdd_tdrestrict\"
")

/* ********************************************************************** */
/* Conversions */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Conversions} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external to_bdd : t -> Bdd.t = \"camlidl_rdd_to_bdd\"
external to_rdd : t -> Rdd.t = \"%identity\"
")

quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 User operations} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {3 By decomposition into guards and leafs} *)")
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(**
Be cautious: here the background leaf is used as a special value,
and should not be used for ordinary purpose.
*)")

quote(MLI,"
val mapleaf1 : (Bdd.t -> int -> int) -> t -> t
val mapleaf2 : (Bdd.t -> int -> int -> int) -> t -> t -> t
")
quote(ML,"
let mapleaf1
  (f:Bdd.t -> int -> int)
  (idd:t)
  :
  t
  =
  let manager = manager idd in
  let background = int_of_float (Manager.get_background manager) in
  let leaves = leaves idd in
  let res = ref (cst manager background) in
  for i=0 to pred (Array.length leaves) do
    let leaf = leaves.(i) in
    if leaf<>background then begin
      let guard = guard_of_leaf idd leaves.(i) in
      let nleaf = f guard leaf in
      res := ite guard (cst manager nleaf) !res
    end
  done;
  !res

let mapleaf2
  (f:Bdd.t -> int -> int -> int)
  (idd1:t)
  (idd2:t)
  :
  t
  =
  let manager = manager idd1 in
  let background = int_of_float (Manager.get_background manager) in
  let ddbackground = cst manager background in
  let leaves1 = leaves idd1 in
  let res = ref ddbackground in
  for i1=0 to pred (Array.length leaves1) do
    let leaf1 = leaves1.(i1) in
    if leaf1<>background then begin
      let guard1 = guard_of_leaf idd1 leaf1 in
      let idd2 = ite guard1 idd2 ddbackground in
      let leaves2 = leaves idd2 in
      for i2=0 to pred (Array.length leaves2) do
	let leaf2 = leaves2.(i2) in
	if leaf2<>background then begin
	  let guard2 = guard_of_leaf idd2 leaf2 in
	  let nleaf = f guard2 leaf1 leaf2 in
	  res := ite guard2 (cst manager nleaf) !res
	end
      done
    end
  done;
  !res
")

quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {3 By using CUDD local cache (efficient and flexible)} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLI,"
val mapunop : (int -> int) -> t -> t
val mapbinop : ?commutative:bool -> ?idempotent:bool -> ?absorbant:(int*int*int*int) -> ?neutral:(int*int) -> (int -> int -> int) -> t -> t -> t
val mapterop : (int -> int -> int -> int) -> t -> t -> t -> t
val mapcmpop : ?bottom:int -> ?top:int -> (int -> int -> bool) -> t -> t -> bool
val mapexistop : absorbant:int -> (int -> int -> int) -> Bdd.t -> t -> t
val mapexistandop : absorbant:int -> (int -> int -> int) -> Bdd.t -> Bdd.t -> t -> t
val mapexistandapplyop : absorbant:int -> (int -> int) -> (int -> int -> int) -> Bdd.t -> Bdd.t -> t -> t
")
quote(ML,"
external _internal_mapunop : bool -> (int -> int) -> t -> t = \"camlidl_rddidd_mapunop\"
external _internal_mapbinop : bool -> bool -> bool -> (int*int*int*int) option -> (int*int) option -> (int -> int -> int) -> t -> t -> t = \"camlidl_rddidd_mapbinop_byte\" \"camlidl_rddidd_mapbinop\"
external _internal_mapterop : bool -> (int -> int -> int -> int) -> t -> t -> t -> t = \"camlidl_rddidd_mapterop\"
external _internal_mapcmpop : bool -> int option -> int option -> (int -> int -> bool) -> t -> t -> bool = \"camlidl_rddidd_mapcmpop_byte\" \"camlidl_rddidd_mapcmpop\"
external _internal_mapexistop : bool -> int -> (int -> int -> int) -> Bdd.t -> t -> t = \"camlidl_cudd_rddidd_mapexistop\"
external _internal_mapexistandop : bool -> int -> (int -> int -> int) -> Bdd.t -> Bdd.t -> t -> t = \"camlidl_cudd_rddidd_mapexistandop_byte\" \"camlidl_cudd_rddidd_mapexistandop\"
external _internal_mapexistandapplyop : bool -> int -> (int -> int) -> (int -> int -> int) -> Bdd.t -> Bdd.t -> t -> t =  \"camlidl_rddidd_mapexistandop_byte\" \"camlidl_rddidd_mapexistandop\"
let mapunop f t = _internal_mapunop true f t
let mapbinop ?(commutative=false) ?(idempotent=false) ?absorbant ?neutral f t1 t2 = _internal_mapbinop true commutative idempotent absorbant neutral f t1 t2
let mapterop f t1 t2 t3 = _internal_mapterop true f t1 t2 t3
let mapcmpop ?bottom ?top cmpop t1 t2 = _internal_mapcmpop true bottom top cmpop t1 t2
let mapexistop ~absorbant op cube t = _internal_mapexistop true absorbant op cube t
let mapexistandop ~absorbant op cube bdd t = _internal_mapexistandop true absorbant op cube bdd t
let mapexistandapplyop ~absorbant op existop cube bdd t = _internal_mapexistandapplyop true absorbant op existop cube bdd t
")

quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {3 By using CUDD mechanism (more efficient, less flexible)} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external alloc_unop: (int -> int) -> id_unop = \"camlidl_idd_alloc_unop\"
external alloc_binop: (int -> int -> int) -> id_binop = \"camlidl_idd_alloc_binop\"
external alloc_combinop: (int -> int -> int) -> id_combinop = \"camlidl_idd_alloc_combinop\"
external apply_unop: id_unop -> t -> t = \"camlidl_idd_apply_unop\"
external apply_binop: id_binop -> t -> t -> t = \"camlidl_idd_apply_binop\"
external apply_combinop: id_combinop -> t -> t -> t = \"camlidl_idd_apply_combinop\"
")
quote(C,"ALLOCAPPLY_USEROP(idd,Val_int,Int_val)")

/* ********************************************************************** */
/* Miscellaneous */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Miscellaneous} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external transfer : t -> Manager.t -> t = \"camlidl_rdd_transfer\"
")

/* ********************************************************************** */
/* Printing */
/* ********************************************************************** */
quote(MLMLI,"(* ====================================================== *)")
quote(MLMLI,"(** {2 Printing} *)")
quote(MLMLI,"(* ====================================================== *)")

quote(MLMLI,"
external _print: t -> unit = \"camlidl_cudd_print\"
")

quote(MLI,"
val print__minterm: Format.formatter -> t -> unit
val print_minterm: (int -> string) -> (int -> string) -> Format.formatter -> t -> unit
val print: (int -> string) -> (int -> string) -> Format.formatter -> t -> unit
")


quote(ML,"
open Format

let print__minterm fmt rdd =
  if is_cst rdd then pp_print_int fmt (dval rdd)
  else
    let nb = nbpaths rdd in
    if nb > (float_of_int !Manager.print_limit) then
      fprintf fmt \"rdd with %i nodes, %i leaves and %g paths\" (size rdd) (nbleaves rdd) nb
  else begin
    fprintf fmt \"@[<v>\";
    let first = ref true in
    iter_cube
      (begin fun cube leaf ->
	if not !first then fprintf fmt \"@ \" else first := false;
	let str = String.create (Array.length cube) in
	Array.iteri
	  (begin fun i elt ->
	    str.[i] <-
	      begin match elt with
	      | Manager.False -> '0'
	      | Manager.True -> '1'
	      | Manager.Top -> '-'
	      end
	  end)
	  cube;
	fprintf fmt \"%s -> %i\" str leaf
      end)
      rdd;
    fprintf fmt \"@]\"
  end

let print_minterm bassoc nassoc fmt rdd =
  if is_cst rdd then pp_print_string fmt (nassoc (dval rdd))
  else
    let nb = nbpaths rdd in
    if nb > (float_of_int !Manager.print_limit) then
      fprintf fmt \"rdd with %i nodes, %i leaves and %g paths\" (size rdd) (nbleaves rdd) nb
  else begin
    let leaves = leaves rdd in
    fprintf fmt \"{ @[<v>\";
    for i=Array.length leaves - 1 downto 0 do
      let leaf = leaves.(i) in
      let bdd = guard_of_leaf rdd leaf in
      fprintf fmt \"%s IF %a\"
	(nassoc leaf) (Bdd.print_minterm bassoc) bdd;
      if i > 0 then
	fprintf fmt \",@ \";
    done;
    fprintf fmt \"@] }\"
  end

let rec print bassoc nassoc formatter rdd =
  match inspect rdd with
  | Leaf(v) -> pp_print_string formatter (nassoc v)
  | Ite(var,alors,sinon) ->
      fprintf formatter \"ITE(@[<hv>%s;@,%a;@,%a)@]\"
	(bassoc var) (print bassoc nassoc) alors (print bassoc nassoc) sinon
")
