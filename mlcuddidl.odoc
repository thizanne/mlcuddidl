{1 Introduction}

This library provides an OCAML interface to the BDD's library
CUDD. The reader is supposed to have looked at the
{{:http://vlsi.colorado.edu/~fabio/CUDD/}user's manual} of this
library.

Most functions of the CUDD library are interfaced; with the
exception of ZDDs functions. If you need it, please tell me, I
can do it quickly.

{2 Outline}

The interface is decomposed in the following modules
{!modules: Manager Bdd Rdd Idd Mtbdd}
{!indexlist}

{2 Memory management}

The diagrams are implemented as abstract types, and more precisely
as OCAML {e custom objects}. These objects contain both the
manager which owns the diagram and the diagram itself. They are
garbage collected by the OCAML garbage collection. The effect of
the OCAML garbage collection is to decrease the reference count of
the diagram if it has become unreachable from the OCAML heap, and
to remove the OCAML custom object from the OCAML heap. Later, the
CUDD may possibly garbage the diagram in the C heap, if its
reference count is zero.

For efficiency reasons, it is better to link in some way the two
garbage collectors. So, when the CUDD garbage collector is
triggered, in a normal situation (during the creation of a new
node) or because of a reordering operation, it first calls the
OCAML garbage collector, in order to be able to garbage collect as
many nodes as possible.

The function {!Manager.set_gc} allows to tune the OCAML garbage
collection of diagrams and the link with the CUDD garbage
collection.

It is possible to apply to the diagrams the polymorphic comparison
test ([Pervasives.compare], from which are derived [=,<=,>=,<,>])
and polymorphic hash function (polymorphic [Hashtbl.hash]). The
comparison function compares lexicographically the pair [address
of the manager, address of the node]). The hash function returns
the address of the node.

{2 This document}

Each module is described separately. For each Ocaml function, we
indicate below in typewriter font the CUDD function to which it
corresponds, whenever possible. If the order of the arguments has
been changed, we usually specify ``variation of'' before.

We do not describe in detail the functions which have a direct
CUDD equivalent. Instead, we refer the user to the original CUDD
documentation.

{2 Organization of the code}

The interface has been written with the help of the CamlIDL tool,
the input files of which are suffixed with [.idl]. CamlIDL
automizes most of the cumbersome task of writing stub codes and
converting datatypes back and forth between C and OCAML. However,
as we implemented more than a direct interface, we also used the
M4 preprocessor on [.idl] files to simplify the task (instead of
the default cpp C preprocessor).

[.idl] files are thus filtered through M4 and transformed
according to the macro file [macros.m4], then CamlIDL generates
from them four files, suffixed with [.c], [.h], [.ml] and [.mli].

[cudd_caml.c] and [cudd_caml.h] are not generated from a [.idl]
file and contain code common to all the other files.  [mtbdd.ml]
and [mtbdd.mli] are also not generated from a [.idl] file.

The normal user doesn't need to understand this process, as the
library is distributed with all the C and OCAML files already
generated.

{2 Installation and Use}

See the [README] file.


You need:
{ul
{- {{:http://www.gnu.org/software/make}GNU Make}}
{- {{:http://vlsi.colorado.edu/software.html}CUDD BDD library}}
{- {{:http://pop-art.inrialpes.fr/people/bjeannet/mlxxxidl-forge/mlcuddidl/index.html}CUDDAUX extension library}}
{- {{:http://caml.inria.fr}OBJECTIVE CAML 3.0}}
{- {{:http://caml.inria.fr/camlidl}CAMLIDL 1.05}}
{- M4 preprocessor, SED, GREP
{{:http://www.gnu.org/software}GNU versions}}
}

Flags should be properly set in [Makefile.config] (starting from
[Makefile.config.model]).

Also, the Make rules for some [example.ml] file shows how to compile 
a program with the interface.

